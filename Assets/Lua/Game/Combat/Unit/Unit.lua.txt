---@class Unit:TickObject
---@field _position Vector3
---@field _rotation Quaternion
---@field _scale number
---@field _buildOkAnimationName string
---@field _currentAttack SpellBase
local Unit = Class("Unit", TickObject)

function Unit:Init()
	Unit.super.Init(self)
	self._isInSight = true -- 是否在视野内，用于优化，由unitManager设置
end



function Unit:UpdateUnit(argDict)
	for key, value in pairs(argDict) do
		if key == "hp" then
			self:SetHp(value)
		elseif key == "faction" then
			self:SetFaction(value)
		elseif key == "level" then
			self:SetLevel(value)
		elseif key == "position" then
			self:SetPosition(value)
		elseif key == "rotation" then
			self:SetRotation(value)
		elseif key == "scale" then
			self:SetScale(value)
		else
			self[key] = value
		end
	end
end

----------------------------------------------------------------------
-- 构建模型相关
----------------------------------------------------------------------
function Unit:Build(argDict)

	---@type UnitLockTargetInfo
	self._unitLockTargetInfo = UnitLockTargetInfo.New()
	---@type ComboInfo
	self._normalAttackComboInfo = ComboInfo.New()
	---@type table<string,UnitModelInfo>  @第一个key是tag
	self._unitModelInfoDict = {}
	self._loadOkListenList = {}
	self._socketTransformDict = {}

	self._argDict = argDict
	self:InitMixedStates()

	self._cfgUnitData = CfgUnit.get_by_id(self._unitId)
	self._name = self._cfgUnitData.name
	self._type = self._cfgUnitData.type
	self._radius = self._cfgUnitData.radius
	self._originalRadius = self._radius

	self._level = argDict.level
	self._unitId = argDict.unitId
	self._playerName = argDict.playerName
	self._showNameOffset = argDict.showNameOffset
	self._isNotShowHeadBlood = argDict.isNotShowHeadBlood
	if argDict.ownerUnitGuid then
		self._ownerUnit = global.client.combat._unitManager:GetUnit(argDict.ownerUnitGuid)
	end
	-- 创建时播放的动画
	self._buildOkAnimationName = argDict.buildOkAnimationName
	-- 是否需要保持尸体
	self._isKeepDeadBody = self._argDict.isKeepDeadBody or self._cfgUnitData.isKeepDeadBody

	self._faction = argDict.faction
	self._position = argDict.position
	self._rotation = argDict.rotation
	self._scale = argDict.scale or self._cfgUnitData.scale or 1
	self:SetScale(self._scale)

	---@type PropertyComp
	self._propertyComp = PropertyComp.New(argDict)
	---@type AnimatorComp
	self._animatorComp = AnimatorComp.New()
	---@type UnitMoveComp
	self._unitMoveComp = self:AddChild(nil, UnitMoveComp, self)
	---@type BuffManager
	self._buffManager = self:AddChild(nil, BuffManager, self)

	---@type table<string,SpellInfo>
	self._spellInfoDict = {  }

	-- 技能相关
	---@type string[]
	self._skillIdList = self._cfgUnitData.skillIds and table.Clone(self._cfgUnitData.skillIds) or {}
	for _, skillId in ipairs(self._skillIdList) do
		self:AddSkill(skillId)
	end

	-- 普攻相关
	---@type string[]
	self._normalAttackIdList = self._cfgUnitData.normalAttackIds and table.Clone(self._cfgUnitData.normalAttackIds) or {}
	for _, normalAttackId in ipairs(self._normalAttackIdList) do
		self:AddNormalAttack(normalAttackId)
	end

	-- 添加被动buff
	for _, passiveBuffId in ipairs(self._cfgUnitData.passiveBuffIds or {}) do
		self._buffManager:AddBuff(passiveBuffId, self)
	end

	if self._cfgUnitData.modelPath then
		self:BuildModel(self._cfgUnitData.modelPath)
	end

	self._unitMoveComp:OnBuild()
	self._animatorComp:OnBuild()
	self._propertyComp:OnBuild(self)

	if argDict.hp_pct then
		self:SetHp(self:GetMaxHp() * argDict.hpPct, true)
	else
		self:SetHp(argDict.hp or self:GetMaxHp(), true)
	end
	self:UpdateMixedStates()
end

function Unit:BuildModel(modelPath)
	global.client.combat._effectManager:DeAttach(self)
	self:_ClearModel()
	self:_StartChangeModel()
	self:_SetModel("main", modelPath)
	self:_FinishChangeModel()
end

function Unit:_ClearModel()
	if IsNotNil(self:GetGraphicComponent()) then
		self:GetGraphicComponent():Reset()
	end
	self:GetGraphicComponent():SetGameObject(nil)
	self._animation = nil
	---@type table<string,CS.UnityEngine.Transform>
	self._socketTransformDict = {}
	self._unitMaterialInfoList = {}
end

function Unit:_StartChangeModel()
	self._isSettingModelPath = true
	self._isLoadOk = false
end

function Unit:_SetModel(tag, modelPath, modelType)
	modelType = modelType or typeof(CS.UnityEngine.GameObject)
	if modelPath == nil then
		self._unitModelInfoDict[tag] = nil
		return
	end
	if not self._unitModelInfoDict[tag] then
		self._unitModelInfoDict[tag] = UnitModelInfo.New()
	end
	local unitModelInfo = self._unitModelInfoDict[tag]
	if unitModelInfo:GetPath() == modelPath then
		return
	end
	unitModelInfo:SetPath(modelPath)
	unitModelInfo:SetPrefab(nil)
	self._resLoadComponent:GetOrLoadAsset(modelPath, function(assetCat)
		local prefab = assetCat:Get(string.GetSubAssetPath(modelPath), modelType)
		self:_OnLoadOK(prefab, tag)
	end)
end

function Unit:_OnLoadOK(prefab, tag)
	local unitModelInfo = self._unitModelInfoDict[tag]
	if not unitModelInfo then
		return
	end
	unitModelInfo:SetPrefab(prefab)
	self:_CheckAllLoadOK()
end

function Unit:_CheckAllLoadOK()
	if self._isSettingModelPath or self:GetGraphicComponent():GetGameObject() then
		return
	end
	for tag, unitModelInfo in pairs(self._unitModelInfoDict) do
		if not unitModelInfo:GetPrefab() then
			return
		end
	end

	local unitModelInfo = self._unitModelInfoDict["main"]
	local clone = GameObject.Instantiate(unitModelInfo:GetPrefab(), self:GetPosition(), self:GetRotation(), self:GetParent():GetGraphicComponent():GetTransform())
	clone.name = string.format("%s:%s", self._unitId, self:GetKey())
	self:GetGraphicComponent():SetGameObject(clone)
	self:_OnBuildOK()
	self._isLoadOk = true
	self:_OnLoadOKListen()
end

function Unit:_OnLoadOKListen()
	for k, loadOkListen in ipairs(self._loadOkListenList) do
		loadOkListen()
	end
	self._loadOkListenList = {}
end

function Unit:_OnBuildOK()
	self:SetPosition(self._position)
	self:SetRotation(self._rotation)
	self.originalTransformScale = self:GetGraphicComponent():GetTransform().localScale
	self:GetGraphicComponent():GetTransform().localScale = self.originalTransformScale * (self._scale or 1)

	self:InitAnimation()
	self:InitMaterial()

	self._unitMoveComp:OnBuildOk()
	self._animatorComp:OnBuildOk(self:GetGraphicComponent():GetGameObject())
	self:Broadcast(UnitEventNameConst.On_Unit_Build_Ok, self)

end

function Unit:InitAnimation()
	---@type CS.UnityEngine.Animation
	self._animation = self:GetGraphicComponent():GetGameObject():GetComponentInChildren(typeof(CS.UnityEngine.Animation))
	if self._animationCullingType then
		self:SetAnimationCullingType(self._animationCullingType)
		---@type CS.UnityEngine.AnimationCullingType
		self._animationCullingType = nil
	end
	if IsNotNil(self._animation) then
		---@type CS.UnityEngine.AnimationState
		local walkAnimationState = self._animation:get_Item(AnimationNameConst.walk)
		if walkAnimationState then
			walkAnimationState.wrapMode = CS.UnityEngine.WrapMode.Loop
		end
		---@type CS.UnityEngine.AnimationState
		local idleAnimationState = self._animation:get_Item(AnimationNameConst.idle)
		if idleAnimationState then
			idleAnimationState.wrapMode = UnityEngine.WrapMode.Loop
			if not self._actionManager then
				idleAnimationState.layer = -1
			end
		end
		---@type CS.UnityEngine.AnimationState
		local dieAnimationState = self._animation:get_Item(AnimationNameConst.die)
		if dieAnimationState then
			dieAnimationState.wrapMode = UnityEngine.WrapMode.ClampForever
		end
		if self._buildOkAnimationName and self._animation:get_Item(self._buildOkAnimationName) then
			self:PlayAnimation(AnimationNameConst.idle)
			self:PlayAnimation(self._buildOkAnimationName)
			---@type CS.UnityEngine.AnimationState
			local buildOkAnimationState = self._animation:get_Item(self._buildOkAnimationName)
			self._graphicComponent._transform.position = Vector3(0.01, 0.01, 0.01)
			self:AddTimer(function()
				self:SetPosition(self._position)
				self:SetRotation(self._rotation)
			end, nil, buildOkAnimationState.length)
		else
			self:PlayAnimation(AnimationNameConst.idle)
		end
	end
end

function Unit:InitMaterial()
	-- 获取所有材质(MeshRenderer、SkinnedMeshRenderer)
	---@type UnitMaterialInfo[]
	self._unitMaterialInfoList = {}
	local rendererTypeList = { typeof(CS.UnityEngine.MeshRenderer), typeof(CS.UnityEngine.SkinnedMeshRenderer) }
	for k, rendererType in ipairs(rendererTypeList) do
		local renderList = self:GetGraphicComponent():GetGameObject():GetComponentsInChildren(rendererType)
		for i = 0, renderList.Length - 1 do
			local material = renderList[i].material
			if material:HasProperty("_Color") then
				---@type UnitMaterialInfo
				local unitMaterialInfo = UnitMaterialInfo.New()
				unitMaterialInfo:SetMaterial(material)
				unitMaterialInfo:SetColor(material.color)
				table.insert(self._unitMaterialInfoList, unitMaterialInfo)
			end
		end
	end
	---@type table<string,Color> @key是tag
	self.changeColorDict = {}
end

function Unit:_FinishChangeModel()
	self._isSettingModelPath = false
	self:_CheckAllLoadOK()
end

----------------------------------------------------------------------
-- Socket相关
----------------------------------------------------------------------
---@return Vector3
function Unit:GetSocketPosition(socketName, isIgnoreError)
	local socketTransform = self:GetSocketTransform(socketName, isIgnoreError)
	if socketTransform then
		return socketTransform.position
	else
		return self:GetPosition()
	end
end

---@return Quaternion
function Unit:GetSocketRotation(socketName, isIgnoreError)
	local socketTransform = self:GetSocketTransform(socketName, isIgnoreError)
	if socketTransform then
		return socketTransform.rotation
	else
		return self:GetPosition()
	end
end

---@return CS.UnityEngine.Transform
function Unit:GetSocketTransform(socketName, isIgnoreError)
	if IsNil(self:GetGraphicComponent():GetGameObject()) then
		return nil
	end
	if not socketName or socketName == "" or socketName == "main" then
		return self._graphicComponent._transform
	end
	local socketTransform = self._socketTransformDict[socketName]
	if not socketTransform then
		socketTransform = self:GetGraphicComponent():GetTransform():FindChildRecursive(socketName)
		if socketTransform then
			self._socketTransformDict[socketName] = socketTransform
		end
	end
	if not socketTransform then
		if not isIgnoreError then
			ErrorFormat("Can't find socket(%s) in unit(%s)", socketName, self._unitId)
		else
			WarnFormat("Can't find socket(%s) in unit(%s)", socketName, self._unitId)
		end
		return self:GetGraphicComponent():GetTransform()
	end
	return socketTransform
end

----------------------------------------------------------------------
-- 伤害相关
----------------------------------------------------------------------
function Unit:TakeDamage(damageValue, sourceUnit, spell)
	if self:IsDead() or self:IsInvincible() then
		return 0
	end
	if self:IsCanNotBeTakeDamage() then
		return 0
	end
	if self._aiComp and self._aiComp.BeHit then
		self._aiComp:BeHit(sourceUnit, damageValue)
	end
	--以后用于计算血条收到伤害效果
	local oldHp = self:GetHp()
	self:SetHp(math.max(0, self:GetHp() - damageValue))
	self:OnHpChange(sourceUnit, oldHp, self:GetHp())
	self:Broadcast(UnitEventNameConst.On_Unit_Hurt, sourceUnit, self, spell, damageValue)

	if self:GetHp() <= 0 then
		self:Broadcast(UnitEventNameConst.On_Before_Unit_Dead, sourceUnit, self, spell, damageValue) --回调监听
		self:OnKilled(sourceUnit, spell)
	end
	return damageValue
end

-- 治疗
function Unit:Heal(healValue, sourceUnit)
	if self:IsDead() or self:IsCanNotBeHeal() then
		return 0
	end
	local oldHp = self:GetHp()
	self:SetHp(math.min(self:GetHp() + healValue, self:GetMaxHp()))
	self:OnHpChange(sourceUnit, oldHp, self:GetHp())
	return healValue
end




----------------------------------------------------------------------
-- 隐身 显隐相关
----------------------------------------------------------------------
function Unit:UpdateHideState()
	if self:IsHide() then
		if self:IsExpose() then
			self:_SetHideMode("隐身状态被显隐")
		else
			self:_SetHideMode("隐身状态没有显隐")
		end
	else
		self:_SetHideMode("非隐形状态")
	end
end

function Unit:_SetHideMode(mode)
	if not self._isLoadOk then
		table.insert(self._loadOkListenList, function()
			self:__SetHideMode(mode)
		end)
		return
	end
	self:__SetHideMode(mode)
end

function Unit:__SetHideMode(mode)
	if mode == "隐身状态被显隐" then
		self:GetGraphicComponent():SetIsShow(true)
		self:ChangeColor("隐身", Color.New(1, 0.2, 1, 0.5)) -- 紫色透明
	elseif mode == "隐身状态没有显隐" then
		self:GetGraphicComponent():SetIsShow(false)
		self:ChangeColor("隐身", nil)
	elseif mode == "非隐形状态" then
		self:GetGraphicComponent():SetIsShow(true)
		self:ChangeColor("隐身", nil)
	end
end
----------------------------------------------------------------------
-- 死亡相关
----------------------------------------------------------------------
---@param spell SpellBase
function Unit:OnKilled(sourceUnit, spell, isPlayDeadAnimation, isWaitingRebirth, isKeepDeadBody)
	self:Broadcast(UnitEventNameConst.On_Unit_Kill_Target, sourceUnit, self, spell)
	if self._unitMoveComp:GetMoveType() == "beThrown" or self._unitMoveComp:IsGetCaught() then
		self._unitMoveComp:SetMoveType(nil)
		self._unitMoveComp:SetIsGetCaught(false)
		---@type UnitBeThrownInfo
		local unitBeThrownInfo = UnitBeThrownInfo.New()
		unitBeThrownInfo:SetEndPos(global.client.combat._pathManager:GetGroundPos(self._position))
		unitBeThrownInfo:SetDuration(0.1)
		unitBeThrownInfo:SetHeight(0)
		self:BeThrown(unitBeThrownInfo)
	end

	if self._unitModelInfoDict["main"]:GetPath() ~= self._cfgUnitData.modelPath then
		self:BuildModel(self._cfgUnitData.modelPath)
	end
	self._isDead = true
	self:UpdateMixedStates()
	if isKeepDeadBody then
		self._isKeepDeadBody = true
	end
	if isPlayDeadAnimation then
		self:MoveStop()
		local deadBodyDelay = self._cfgUnitData.deadBodyDelay or 0.5
		local deathEffectId = self._cfgUnitData.deathEffectId
		if deathEffectId then
			local cfgEffectData = CfgEffect.get_by_id(deathEffectId)
			local groundEffectPos = self:GetSocketPosition(cfgEffectData.socketName1)
			global.client.combat._effectManager:CreateGroundEffect(deathEffectId, self, groundEffectPos, self:GetRotation():ToEulerAngles(), cfgEffectData.duration)
		end
		if IsNotNil(self._animation) then
			---@type CS.UnityEngine.AnimationState
			local dieAnimationState = self._animation:get_Item(AnimationNameConst.die)
			if dieAnimationState then
				self:PlayAnimation(AnimationNameConst.die)
				deadBodyDelay = dieAnimationState.length + 1
			end
			if not isWaitingRebirth then
				self:AddTimer(function()
					self:_OnDieOver()
				end, nil, deadBodyDelay)
			end
		else
			self._animatorComp:PlayAnimation(AnimationNameConst.die, true)
			self:AddTimer(function()
				self:_OnDieOver()
			end, nil, deadBodyDelay)
		end
	else
		global.client.combat._unitManager:RemoveUnit(self._key)
	end
end

function Unit:_OnDieOver()
	if self._isKeepDeadBody then
		return
	end
	if self._cfgUnitData.deathEffectId then
		self:SetIsMoveWithMoveAnimation(false)
		self:AddTimer(function()
			self:_OnDieBuryOver()
		end, nil, 3)
	else
		self:_OnDieBuryOver()
	end
end

function Unit:_OnDieBuryOver()
	global.client.combat._unitManager:RemoveUnit(self._key)
end

----------------------------------------------------------------------
-- Faction相关
----------------------------------------------------------------------
function Unit:SetFaction(newFaction)
	local oldFaction = self._faction
	self._faction = newFaction
	self:OnFactionChange(oldFaction, newFaction)
end

function Unit:GetFaction()
	return self._faction
end

function Unit:OnFactionChange(oldValue, newValue)
	if oldValue ~= newValue then
		self:Broadcast(UnitEventNameConst.On_Unit_Faction_Change, self:GetGuid(), oldValue, newValue)
	end
end

----------------------------------------------------------------------
-- 属性相关
----------------------------------------------------------------------
function Unit:OnPropertyChanged(oldCalcPropDict, newCalcPropDict, calcPropDictDiff)
	for key, value in pairs(calcPropDictDiff) do
		local oldValue = oldCalcPropDict[key]
		if key == "技能冷却减少百分比" or key == "攻击速度" then
			self:OnSpellCoolDownRateChange()
		elseif key == "移动速度" then
			self:OnSpeedChange(oldValue, value)
		elseif key == "生命上限" then
			self:OnMaxHpChange(oldValue, value)
		end
	end
end

function Unit:GetCalcPropValue(propertyKey)
	return self._propertyComp.calcPropDict[propertyKey]
end



----------------------------------------------------------------------
-- Buff,State相关
----------------------------------------------------------------------
function Unit:HasBuff(buffId)
	return self._buffManager:IsHasBuff(buffId)
end

function Unit:GetBuffCount()
	return self._buffManager:GetBuffCount()
end

function Unit:GetDebuffCount()
	return self._buffManager:GetDebuffCount()
end

function Unit:HasState(stateName)
	return self._buffManager:IsHasState(stateName)
end

-- 混合状态
function Unit:InitMixedStates()
	self._isDead = false

	self._isCanMove = true
	self._isCanAttack = true
	self._isCanCastSkill = true
	self._isCanNormalAttack = true
	self._isCanControl = true
end

-- 混合状态
function Unit:UpdateMixedStates()
	-- 是否是正常状态
	local isCommonState = not self:IsDead() and
		not self:IsStun() and
		not self:IsFreeze() and
		not self._unitMoveComp:GetUnitBeThrownInfo() and
		not self._unitMoveComp:IsGetCaught() and true or false
	local newIsCanMove = isCommonState and
		not self:HasState(StateConst.CanNotMove) and
		(not self._currentAttack or
			self._currentAttack:IsPastBreakTime() or
			self._currentAttack._cfgSpellData.isCanMoveWhileCast) and true or false
	local newIsCanAttack = isCommonState and
		(not self:HasState(StateConst.CanNotAttack)) and
		(not self._currentAttack or
			self._currentAttack:IsPastBreakTime()) and true or false
	local newIsSilent = self:IsSilent()
	local newIsCanCastSkill = newIsCanAttack and not newIsSilent and true or false
	local newIsCanNormalAttack = newIsCanAttack and true or false

	local newIsConfused = self:IsConfused() and true or false
	local newIsCanOperate = isCommonState and not newIsConfused and true or false
	local newIsCanControl = (newIsCanMove or newIsCanAttack) and newIsCanOperate and true or false
	-- 检查混合状态变化
	if self._isCanMove ~= newIsCanMove then
		self._isCanMove = newIsCanMove
		self:Broadcast(UnitEventNameConst.On_Unit_Is_Can_Move_Change, self, not self._isCanMove, self._isCanMove)
		if not self._isCanMove then
			self:MoveStop()
		end
	end
	if self._isCanAttack ~= newIsCanAttack then
		self._isCanAttack = newIsCanAttack
		self:Broadcast(UnitEventNameConst.On_Unit_Is_Can_Attack_Change, self, not self._isCanAttack, self._isCanAttack)
	end
	if self._isCanCastSkill ~= newIsCanCastSkill then
		self._isCanCastSkill = newIsCanCastSkill
		self:Broadcast(UnitEventNameConst.On_Unit_Is_Can_Cast_Skill_Change, self, not self._isCanCastSkill, self._isCanCastSkill)
		if not self._isCanCastSkill and (self._currentAttack and table.ContainsValue(self._skillIdList, self._currentAttack._spellId)) then
			global.client.combat._spellManager:BreakSpell(self._currentAttack:GetGuid())
		end
	end
	if self._isCanNormalAttack ~= newIsCanNormalAttack then
		self._isCanNormalAttack = newIsCanNormalAttack
		self:Broadcast(UnitEventNameConst.On_Unit_Is_Can_Normal_Attack_Change, self, not self._isCanNormalAttack, self._isCanNormalAttack)
		if not self._isCanNormalAttack and (self._currentAttack and table.ContainsValue(self._normalAttackIdList, self._currentAttack._spellId)) then
			global.client.combat._spellManager:BreakSpell(self._currentAttack:GetGuid())
		end
	end

	if self._isCanControl ~= newIsCanControl then
		self._isCanControl = newIsCanControl
		self:Broadcast(UnitEventNameConst.On_Unit_Is_Can_Control_Change, self, not self._isCanControl, self._isCanControl)
	end
end



----------------------------------------------------------------------
-- Move相关
----------------------------------------------------------------------
---@param moveToTargetPos Vector3
---@param duration number
function Unit:_MoveTo(moveToTargetPos, duration)
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
	moveToTargetPos = self._cfgUnitData.offsetY and (moveToTargetPos + Vector3(0, self._cfgUnitData.offsetY, 0)) or moveToTargetPos
	global.client.moveManager:MoveTo(self._graphicComponent._transform, moveToTargetPos, duration)
end

function Unit:StopMoveTo()
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
	global.client.moveManager:StopMoveTo(self._graphicComponent._transform)
end

function Unit:Move(targetPos, speed)
	if not self:IsCanMove() then
		return
	end
	self._unitMoveComp:Move(targetPos, speed)
end

function Unit:MoveByPath(path, speed)
	if not self:IsCanMove() then
		return
	end
	self._unitMoveComp:MoveByPath(path, speed)
end

function Unit:MoveStop(rotation, pos)
	self._unitMoveComp:MoveStop(rotation, pos)
end

function Unit:BeThrown(unitBeThrownInfo)
	if self:IsDead() or self:IsImmuneControl() then
		return
	end
	self._unitMoveComp:BeThrown(unitBeThrownInfo)
end

function Unit:StopBeThrown(isEnd)
	self._unitMoveComp:StopBeThrown(isEnd)
end

function Unit:SetIsMoveWithMoveAnimation(isMoveWithMoveAnimation)
	self._unitMoveComp:SetIsMoveWithMoveAnimation(isMoveWithMoveAnimation)
end

function Unit:FaceTo(rotation)
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
end

function Unit:OnlyFaceTo(rotation)
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
end

function Unit:FaceToDir(dir)
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
end

function Unit:OnlyFaceToDir(dir)
	if not self:GetGraphicComponent():GetTransform() then
		return
	end
end

function Unit:LookAt(unitOrEulerAngle, mode)
	self._unitMoveComp:LookAt(unitOrEulerAngle, mode)
end

----------------------------------------------------------------------
-- Animation相关
----------------------------------------------------------------------
function Unit:SetAnimationCullingType(animationCullingType)
	if not self._animation then
		self._animationCullingType = animationCullingType
		return
	end
	self._animation.cullingType = animationCullingType
end

function Unit:PlayAnimation(animationName, blendTime, speed, faceToPosition, isNotMoveStop)
	blendTime = blendTime or 0.1
	speed = speed or 1
	if IsNotNil(self._animation) then
		if self._curAnimationName == AnimationNameConst.die then
			return
		end
		if self._actionManager then
			if animationName == AnimationNameConst.walk and self._curAnimationName then
				self._actionManager:Stop(self._curAnimationName)
				self._curAnimationName = nil
			end
			if animationName == AnimationNameConst.idle then
				self._actionManager:Play(animationName, speed, -1, false)
			elseif animationName == AnimationNameConst.walk then
				self._actionManager:Play(animationName, speed, 0, false)
			else
				self._actionManager:Play(animationName, speed, 0, true)
				self._curAnimationName = animationName
				if animationName == AnimationNameConst.die then
					self._actionManager:Stop(AnimationNameConst.idle)
				end
			end
		else
			if animationName == AnimationNameConst.walk and self._curAnimationName then
				self._animation:Blend(self._curAnimationName, 0, blendTime)
				self._curAnimationName = nil
			end
			local animationState = self._animation:get_Item(animationName)
			if not animationState then
				ErrorFormat("animation is no exist: %s , %s", animationName, self._unitId)
			end
			local speedThreshold = 0.5
			if animationName == AnimationNameConst.walk and speed < speedThreshold then
				animationState.speed = speedThreshold
				self._animation:CrossFade(animationName, blendTime)
				self._animation:Blend(animationName, speed / speedThreshold, blendTime)
			else
				animationState.speed = speed
				self._animation:CrossFade(animationName, blendTime)
			end
			if not (animationName == AnimationNameConst.idle or animationName == AnimationNameConst.walk) then
				if self._curAnimationName == animationName then
					self._animation:get_Item(animationName).time = 0
				end
				self._curAnimationName = animationName
			end
		end
	else
		self._animatorComp:PlayAnimation(animationName, true, speed)
	end

	if faceToPosition then
		local rotation = Quaternion.LookRotation(faceToPosition - self:GetPosition())
		if rotation and not isNotMoveStop then
			self:MoveStop(rotation)
		end
	end
end

function Unit:StopAnimation(animationName, blendTime)
	--Warn("Unit:StopAnim", anim_name, blend_time);
	blendTime = blendTime or 0.1
	if IsNotNil(self._animation) then
		if self._actionManager then
			self._actionManager:Stop(animationName)
		else
			animationName = animationName or self._curAnimationName
			self._animation:Blend(animationName, 0, blendTime)
		end
	end
end
----------------------------------------------------------------------
-- AI相关
----------------------------------------------------------------------
function Unit:RunAI(aiClassPath)
	local aiClass = aiClassPath and ClassLoadUtil.Load(aiClassPath) or AIBaseComp
	if self._aiComp then
		self:RemoveChild(self._aiComp:GetKey())
	end
	self._aiComp = self:AddChild(nil, aiClass, self)
end


----------------------------------------------------------------------
-- 变色相关
----------------------------------------------------------------------
-- 改变一个物体上MeshRenderer、SkinMeshRenderer材质的颜色
function Unit:ChangeColor(tag, color)
	if not self._unitMaterialInfoList or #self._unitMaterialInfoList < 1 then
		return
	end

	self.changeColorDict[tag] = color
	self:_UpdateColor()
end

function Unit:_UpdateColor()
	local currentColor = Color.white
	for k, color in pairs(self.changeColorDict) do
		currentColor = currentColor * color
	end

	for k, unitMaterialInfo in ipairs(self._unitMaterialInfoList) do
		unitMaterialInfo._material.color = unitMaterialInfo._color * currentColor
	end
end

----------------------------------------------------------------------
-- 普攻相关
----------------------------------------------------------------------
function Unit:AddNormalAttack(normalAttackId)
	if not normalAttackId then
		return
	end
	table.insert(self._normalAttackIdList, normalAttackId)
	self:InitSpellInfo(normalAttackId)
	self:AddPassiveBuffOfSpell(normalAttackId)
end

function Unit:GetNormalAttackId()
	local nextIndex = self._normalAttackComboInfo:GetNextIndex()
	if CombatUtil.GetTime() > self._normalAttackComboInfo:GetNextTime() or
		not self._normalAttackIdList[self._normalAttackComboInfo:GetNextIndex()] then
		nextIndex = 1
	end
	local normalAttackId = self._normalAttackIdList[nextIndex]
	return normalAttackId
end

---@param targetUnit Unit
function Unit:NormalAttack(targetUnit)
	local normalAttackId = self:GetNormalAttackId()
	local normalAttack = global.client.combat._spellManager:CastSpell(self, normalAttackId, targetUnit, nil, true)
	if normalAttack then
		self._lastAttackId = normalAttackId
	end
	return normalAttack
end

function Unit:NormalAttackStart()
	self._normalAttackComboInfo:SetNextTime(CombatUtil.GetTime() + ComboConst.Normal_Attack_Combo_Max_Duration) -- 1秒间隔触发combo
	self._normalAttackComboInfo:SetNextIndex(self._normalAttackComboInfo._nextIndex + 1)
	self._isNormalAttacking = true
end

function Unit:NormalAttackFinish()
	self._normalAttackComboInfo:SetNextTime(CombatUtil.GetTime() + 0.2)
	self._isNormalAttacking = true
end

----------------------------------------------------------------------
-- 技能相关
----------------------------------------------------------------------
function Unit:AddSkill(skillId)
	if not skillId then
		return
	end
	table.insert(self._skillIdList, skillId)
	self:InitSpellInfo(skillId)
	self:AddPassiveBuffOfSpell(skillId)
end

---@param targetUnit Unit
---@param isControl @是否是控制类技能
function Unit:CastSkillByIndex(index, targetUnit, isControl)
	local skillId = self._skillIdList[index]
	if not skillId then
		Error("index error ", index)
		return
	end
	return self:CastSpell(skillId, targetUnit, isControl)
end

----------------------------------------------------------------------
-- spell相关
----------------------------------------------------------------------
function Unit:InitSpellInfo(spellId, coolDownPct)
	---@type SpellInfo
	local spellInfo = SpellInfo.New()
	self._spellInfoDict[spellId] = spellInfo
	self:SetSpellInfoCoolDown(spellId, coolDownPct)
end

function Unit:GetSpellCoolDownRate(spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	if cfgSpellData.type == "普攻" then
		return 1 / (1 + self:GetCalcPropValue("攻击速度"))
	else
		return 1 - self:GetCalcPropValue("技能冷却减少百分比")
	end
end

function Unit:GetSpellIdList(spell_id)
	local cfgSpellData = CfgSpell.get_by_id(spell_id)
	if cfgSpellData.type == "普攻" then
		return self._normalAttackIdList
	else
		return self._skillIdList
	end
end

function Unit:SetSpellInfoCoolDown(spellId, coolDownPct)
	coolDownPct = coolDownPct or 0
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	local spellInfo = self._spellInfoDict[spellId]
	spellInfo:SetCoolDownRate(self:GetSpellCoolDownRate(spellId))
	spellInfo:SetCoolDownRemainDuration(cfgSpellData.coolDownDuration * spellInfo._coolDownRate * coolDownPct)
end

function Unit:AddPassiveBuffOfSpell(spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	local passiveBuffIds = cfgSpellData.passiveBuffIds
	if passiveBuffIds then
		for _, passiveBuffId in ipairs(passiveBuffIds) do
			self._buffManager:AddBuff(passiveBuffId, self)
		end
	end
end

function Unit:RemoveSpell(spellId)
	local spellIdList = self:GetSpellIdList(spellId)
	table.RemoveByValue_Array(spellIdList, spellId)
	self._spellInfoDict[spellId] = nil
	self:RemovePassiveBuffOfSpell(spellId)
end

function Unit:RemovePassiveBuffOfSpell(spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	local passiveBuffIds = cfgSpellData.passiveBuffIds
	if passiveBuffIds then
		self._buffManager:RemoveBuff(passiveBuffIds, self:GetGuid())
	end
end

--  替换单位spell
function Unit:ReplaceSpell(oldSpellId, newSpellId, isResetCoolDownRemainDuration)
	local spellIdList = self:GetSpellIdList(oldSpellId)
	local index = table.IndexOf_Array(spellIdList, oldSpellId)
	spellIdList[index] = newSpellId

	-- 更新coolDown
	local coolDownCurPct = 0
	if not isResetCoolDownRemainDuration then
		coolDownCurPct = self._spellInfoDict[oldSpellId]:GetCoolDownPct()
	end
	self:InitSpellInfo(newSpellId, coolDownCurPct)
	self._spellInfoDict[oldSpellId] = nil


	--  删除原技能被动buff
	self:RemovePassiveBuffOfSpell(oldSpellId)
	--  添加新技能被动buff
	self:AddPassiveBuffOfSpell(newSpellId)

end



--  改变技能CD
function Unit:OnSpellCoolDownRateChange()
	for spellId, spellInfo in pairs(self._spellInfoDict) do
		local cfgSpellData = CfgSpell.get_by_id(spellId)
		local coolDownOldRate = spellInfo:GetCoolDownRate()
		local coolDownDuration = cfgSpellData.coolDownDuration or 0
		if coolDownDuration > 0 then
			local newRate = self:GetSpellCoolDownRate(spellId)
			if spellInfo:GetCoolDownRemainDuration() <= 0 then
				spellInfo:SetCoolDownRemainDuration(0)
			else
				--local coolDown_cur_pct = spellInfo.coolDown_remain_duration/(coolDown_duration * coolDown_last_rate)
				--local coolDown_remain_duration = coolDown_cur_pct * (coolDown_duration * new_rate)
				spellInfo:SetCoolDownRemainDuration(spellInfo:GetCoolDownRemainDuration() * newRate / coolDownOldRate)
			end
			spellInfo:SetCoolDownRate(newRate)
		end
	end
end

function Unit:ReduceSpellCoolDown(deltaTime)
	for _, spellInfo in pairs(self._spellInfoDict) do
		if spellInfo:GetCoolDownRemainDuration() > 0 then
			spellInfo:SetCoolDownRemainDuration(math.max(0, spellInfo._coolDownRemainDuration - deltaTime))
		end
	end
end

function Unit:IsSpellCoolDownOk(spellId)
	if self._spellInfoDict[spellId]:GetCoolDownRemainDuration() == 0 then
		return true
	end
	return false
end

---@param targetUnit Unit
---@param isControl @是否是控制类技能
function Unit:CastSpell(spellId, targetUnit, isControl)
	local spell = global.client.combat._spellManager:CastSpell(self, spellId, targetUnit, nil, isControl)
	if spell then
		self._lastAttackId = spellId
	end
	return spell
end

---@param newCfgSpellData CfgSpellData
function Unit:CanBreakCurrentSpell(newSpellId, newCfgSpellData)
	if not self._currentAttack then
		return true
	end
	newCfgSpellData = newCfgSpellData or CfgSpell.get_by_id(newSpellId)
	if (newCfgSpellData.type == "法术" and self._currentAttack._cfgSpellData.type == "普攻") -- 法术可以打断普攻
		or newCfgSpellData.castType == "触发" then
		return true
	else
		return self._currentAttack:IsPastBreakTime()
	end
end


--  检查是否到时间可以放技能1、是否能打断当前技能2、技能cd是否到
function Unit:IsTimeToCastSpell(spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	if not self:CanBreakCurrentSpell(spellId, cfgSpellData) then
		return false
	end
	if not self:IsSpellCoolDownOk(spellId) then
		return false
	end
	return true
end

function Unit:IsInSpellRange(target, spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	if not cfgSpellData.range then
		return false
	end
	return cfgSpellData.range >= self:Distance(target)
end

----------------------------------------------------------------------
-- Util相关
----------------------------------------------------------------------
function Unit:SetPosition(pos)
	if self:GetGraphicComponent():GetTransform() then
		self:GetGraphicComponent():GetTransform().position = self._cfgUnitData.offsetY and (pos + Vector3(0, self._cfgUnitData.offsetY, 0)) or pos
	end
	self._position = pos
end

function Unit:GetPosition()
	return self._position
end

function Unit:SetRotation(rotation)
	if self:GetGraphicComponent():GetTransform() then
		self:GetGraphicComponent():GetTransform().rotation = rotation
	end
	self._rotation = rotation
end

function Unit:GetRotation()
	return self._rotation
end

---@param scale number
function Unit:SetScale(scale)
	if self:GetGraphicComponent():GetTransform() then
		self:GetGraphicComponent():GetTransform().localScale = self.originalTransformScale * scale
	end
	self._scale = scale
	self._radius = self._originalRadius * scale
end

function Unit:GetScale()
	return self._scale
end

function Unit:SetLevel(level)
	self._level = level
	self._propertyComp:_CalculateProp()
end

function Unit:GetLevel()
	return self._level
end

function Unit:GetRadius()
	return self._radius
end

---@param target Unit|CS.UnityEngine.Transform|Vector3|IPosition
function Unit:Distance(target)
	local radius = self._radius
	if IsUnit(target) then
		radius = radius + target._radius
		target = target:GetPosition()
	elseif IsTransform(target) then
		target = target._position
	elseif IsVector3(target) then
		target = target
	elseif IsIPosition(target) then
		if target.unit then
			return self:Distance(target.unit)
		else
			return self:Distance(target:GetPosition())
		end
	end
	return Vector3.Distance(self:GetPosition() - target) - radius
end

function Unit:GetMaxHp()
	return self:GetCalcPropValue("生命上限")
end

function Unit:SetHp(hp, isNotBroadcast)
	local oldValue = self.hp
	hp = math.fmod(hp) -- 取整
	self.hp = math.min(hp, self:GetMaxHp())
	if not isNotBroadcast then
		self:OnHpChange(nil, oldValue, self.hp)
	end
end

function Unit:OnHpChange(sourceUnit, oldValue, newValue)
	self:Broadcast(UnitEventNameConst.On_Unit_Hp_Change, sourceUnit, self, oldValue, newValue)
end

function Unit:OnMaxHpChange(oldValue, newValue)
	self:Broadcast(UnitEventNameConst.On_MaxHp_Change, self, oldValue, newValue)
end

function Unit:GetHp()
	return self.hp
end

function Unit:GetSpeed()
	return self:GetCalcPropValue("移动速度")
end

function Unit:OnSpeedChange(oldValue, newValue)
	self._unitMoveComp:OnSpeedChange(oldValue, newValue)
end


-- 能否移动
function Unit:IsCanMove()
	return self._isCanMove
end

-- 能否攻击（包括普攻和技能）
function Unit:IsCanAttack()
	return self._isCanAttack
end

-- 能否普攻
function Unit:IsCanNormalAttack()
	return self._isCanNormalAttack
end

-- 能否释放技能
function Unit:IsCanCastSkill()
	return self._isCanCastSkill
end

-- 能否被控制
function Unit:IsCanControl ()
	return self._isCanControl
end

-- 是否混乱状态
function Unit:IsConfused ()
	return self:HasState(StateConst.Confused)
end

-- 是否无敌
function Unit:IsInvincible()
	return self:HasState(StateConst.Invincible)
end

-- 是否昏眩状态
function Unit:IsStun()
	return self:HasState(StateConst.Stun)
end

-- 是否冰冻状态
function Unit:IsFreeze()
	return self:HasState(StateConst.Freeze)
end

-- 是否沉默状态
function Unit:IsSilent()
	return self:HasState(StateConst.Silent)
end

-- 是否免控状态
function Unit:IsImmuneControl()
	return self:HasState(StateConst.ImmuneControl)
end

-- 是否不受伤害状态
function Unit:IsCanNotBeTakeDamage()
	return self:HasState(StateConst.CanNotBeTakeDamage)
end

-- 是否不能被治疗状态
function Unit:IsCanNotBeHeal ()
	return self:HasState(StateConst.CanNotBeHeal)
end

-- 是否隐身状态
function Unit:IsHide()
	return self:HasState(StateConst.Hide)
end

-- 是否反隐状态
function Unit:IsExpose()
	return self:HasState(StateConst.Expose)
end

-- 是否死亡
function Unit:IsDead()
	return self._isDead
end

--是否在视野内
function Unit:IsInSight()
	return self._isInSight
end

function Unit:SetCurrentAttack(currentAttack)
	self._currentAttack = currentAttack
end

function Unit:GetCurrentAttack()
	return self._currentAttack
end

function Unit:IsNormalAttacking()
	return self._isNormalAttacking
end

function Unit:GetPropertyComp()
	return self._propertyComp
end

function Unit:SetActionDict(_actionDict)
	self._actionDict = _actionDict
end

function Unit:GetActionDict()
	return self._actionDict
end

function Unit:GetUnitId()
	return self._unitId
end

function Unit:GetBuffManager()
	return self._buffManager
end

function Unit:GetSkillIdList()
	return self._skillIdList
end

function Unit:SetIsMoveOccupy(isMoveOccupy)
	self._isMoveOccupy = isMoveOccupy
end

function Unit:IsMoveOccupy()
	return self._isMoveOccupy
end

function Unit:_Destroy()
	Unit.super._Destroy(self)
	self:Broadcast(UnitEventNameConst.On_Unit_Destroy, self)
	if self._animatorComp then
		self._animatorComp:Destroy()
	end
	if self._propertyComp then
		self._propertyComp:Destroy()
	end
	self._unitModelInfoDict = nil
	self._animation = nil
	self._actionManager = nil
	self._socketTransformDict = nil
	self._unitMaterialInfoList = nil
end

return Unit