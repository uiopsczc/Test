---@class UnitMoveComp:TickObject
---@field unitMoveInfo UnitMoveInfo
---@field unitBeThrownInfo UnitBeThrownInfo
---@field isGetCaught boolean
local UnitMoveComp = Class("UnitMoveComp", TickObject)

---@param unit Unit
function UnitMoveComp:Init(unit)
	UnitMoveComp.super.Init(self, unit)
	self.unit = unit
	self.walkStepLength = unit.cfgUnitData.walkStepLength or 1
	self.moveType = nil  -- move beThrown
	self.isMoveWithMoveAnimation = true
	self.adjustDistSqr = 3 * 3

	self.unitMoveInfo = UnitMoveInfo.New()
	self.unitMoveInfo.speed = unit:GetSpeed()
	self.unitMoveInfo.targetPos = unit:GetPosition()
	self.unitMoveInfo.endRotation = unit:GetRotation()
	---@type UnitLookAtInfo
	self.unitLookAtInfo = UnitLookAtInfo.New()
end

function UnitMoveComp:__Update(deltaTime, unscaledDeltaTime)
	UnitMoveComp.super.__Update(self, deltaTime, unscaledDeltaTime)
	self:__UpdateMove(deltaTime)
	--if self.unitLookAtInfo:HasLookAt() then
	--  self:__UpdateLookAt(deltaTime)
	--end
	if self.unitBeThrownInfo then
		self:__UpdateBeThrown(deltaTime)
	end
end

function UnitMoveComp:__Destroy()
	UnitMoveComp.super.__Destroy(self)
	self.unit = nil
end

function UnitMoveComp:OnBuild()
end

function UnitMoveComp:OnBuildOk()
	local unit = self.unit
	if self.moveType == "move" then
		if self.unitMoveInfo:IsHasAnimationName() and self.isMoveWithMoveAnimation then
			unit:PlayAnimation(self.unitMoveInfo.animationName, 0, self.unitMoveInfo.animationSpeed)
		end
		unit:__MoveTo(self.unitMoveInfo.targetPos, self.unitMoveInfo.remainDuration)
	end
end

----------------------------------------------------------------------
-- Move相关
----------------------------------------------------------------------
function UnitMoveComp:Move(targetPos, speed, animationName)
	self:MoveByPath({ targetPos }, speed, animationName)
end
function UnitMoveComp:MoveByPath(path, speed, animationName)
	local unit = self.unit
	if not unit:IsCanMove() then
		return
	end
	self.moveType = "move"
	if path[1] and not unit.isInSight then
		unit:SetPosition(path[1])
	end
	self.unitMoveInfo.path = path
	if speed then
		self.unitMoveInfo.speed = speed
	end
	if animationName then
		self.unitMoveInfo.animationName = animationName
	end
	local lastMoveAnimationSpeed = self.unitMoveInfo.animationSpeed
	self.unitMoveInfo.animationSpeed = self.unitMoveInfo.speed / self.walkStepLength
	if self.unitMoveInfo:IsHasAnimationName()
		and self.isMoveWithMoveAnimation
		and math.abs(self.unitMoveInfo.animationSpeed - lastMoveAnimationSpeed) > 0.2 then
		unit:PlayAnimation(self.unitMoveInfo.animationName, 0.2, self.unitMoveInfo.animationSpeed)
	end
	self:__MoveNextTarget(2)
end

function UnitMoveComp:__MoveNextTarget(index)
	local unit = self.unit
	if index then
		self.unitMoveInfo.targetIndexInPath = index
	else
		self.unitMoveInfo.targetIndexInPath = self.unitMoveInfo.targetIndexInPath + 1
	end
	self.unitMoveInfo.targetPos = self.unitMoveInfo.path[self.unitMoveInfo.targetIndexInPath]
	if self.unitMoveInfo.targetPos then
		local originPos = self.unitMoveInfo.path[self.unitMoveInfo.targetIndexInPath - 1]
		local distance = Vector3.Distance(self.unitMoveInfo.targetPos, originPos)
		self.unitMoveInfo.remainDuration = distance / self.unitMoveInfo.speed
		unit:__MoveTo(self.unitMoveInfo.targetPos, self.unitMoveInfo.remainDuration)
		self.unitMoveInfo.endRotation = Quaternion.LookRotation(self.unitMoveInfo.targetPos - unit:GetPosition()) or unit:GetRotation()
		self.unitMoveInfo.rotateRemainDuration = Quaternion.Angle(self.unitMoveInfo.endRotation, unit:GetRotation()) / 1080
	else
		self:MoveStop()
	end
end

function UnitMoveComp:MoveStop(rotation, pos)
	local unit = self.unit
	if pos and
		(not unit.isInSight or
			(unit.position - pos):SqrMagnitude() > self.adjustDistSqr) then
		unit:SetPosition(pos)
	end
	if rotation then
		self.unitMoveInfo.endRotation = rotation
		self.unitMoveInfo.rotateRemainDuration = Quaternion.Angle(rotation, unit.rotation) / 720
	end
	if not self.moveType then
		return
	end
	if self.moveType == "move"
		and self.isMoveWithMoveAnimation
		and self.unitMoveInfo:IsHasAnimationName() then
		if IsNotNil(unit.animation) then
			unit:StopAnimation(self.unitMoveInfo.animationName, 0.2)  -- animation动画是层叠的，停掉walk自动就播放idle
		else
			unit.animatorComp:PlayAnimation(AnimationNameConst.idle, true)
		end
	end
	self.moveType = nil
	self.unitMoveInfo.remainDuration = 0
	self.unitMoveInfo.animationSpeed = -1
	unit:StopMoveTo()
end

function UnitMoveComp:__UpdateMove(deltaTime)
	local unit = self.unit
	local deltaTimeRemainDuration = deltaTime
	while self.moveType == "move" and deltaTimeRemainDuration > 0 do
		local newPos
		if self.unitMoveInfo.remainDuration > deltaTimeRemainDuration then
			newPos = Vector3.Lerp(unit:GetPosition(), self.unitMoveInfo.targetPos, deltaTimeRemainDuration / self.unitMoveInfo.remainDuration)
			self.unitMoveInfo.remainDuration = self.unitMoveInfo.remainDuration - deltaTimeRemainDuration
			deltaTimeRemainDuration = 0
		else
			newPos = self.unitMoveInfo.targetPos
			deltaTimeRemainDuration = deltaTimeRemainDuration - self.unitMoveInfo.remainDuration
		end
		local lookDir
		if unit.unitLockTargetInfo:IsHasLockTarget() then
			lookDir = unit.unitLockTargetInfo:GetLockTargetPosition() - unit:GetPosition()
		else
			lookDir = newPos - unit:GetPosition()
		end
		unit:OnlyFaceToDir(lookDir)
		unit:SetPosition(newPos)
		if deltaTimeRemainDuration > 0 then
			self:__MoveNextTarget()
		end
	end
	if self.unitMoveInfo.lookAtUnit then
		if self.unitMoveInfo.lookAtUnit:IsDead() then
			self.lookAtUnit = nil
			return
		end
		local dir = self.unitMoveInfo.lookAtUnit:GetPosition() - unit:GetPosition()
		local angle = Vector3.Angle(unit:GetRotation():Forward(), dir)
		if angle > 5 then
			local targetRotation = Quaternion.LookRotation(dir) or unit.rotation
			unit:SetRotation(Quaternion.Slerp(unit:GetRotation(), targetRotation, 0.3))
		end
	else
		if self.unitMoveInfo.rotateRemainDuration > 0 then
			if self.unitMoveInfo.rotateRemainDuration <= deltaTime then
				unit:SetRotation(self.unitMoveInfo.endRotation)
				self.unitMoveInfo.rotateRemainDuration = 0
			else
				unit:SetRotation(Quaternion.Slerp(unit:GetRotation(), self.unitMoveInfo.endRotation, deltaTime / self.unitMoveInfo.rotateRemainDuration))
				self.unitMoveInfo.rotateRemainDuration = self.unitMoveInfo.rotateRemainDuration - deltaTime
			end
		end
	end
end


----------------------------------------------------------------------
-- beThrown相关
----------------------------------------------------------------------
---@param unitBeThrownInfo UnitBeThrownInfo
function UnitMoveComp:BeThrown(unitBeThrownInfo)
	local endPos = unitBeThrownInfo.endPos
	local duration = unitBeThrownInfo.duration
	local height = unitBeThrownInfo.height
	local endRotation = unitBeThrownInfo.endRotation
	local rotateDuration = unitBeThrownInfo.rotateDuration
	if self.moveType == "beThrown" then
		return
	end
	local unit = self.unit
	self.moveType = "beThrown"
	if unitBeThrownInfo:IsHasAnimationName() and IsNotNil(unit.animation) then
		self.unit:PlayAnimation(unitBeThrownInfo.animationName)
	end
	self.unitBeThrownInfo = unitBeThrownInfo
	self.unit:UpdateMixedStates()
	self.unitBeThrownInfo.orgHeight = unit:GetPosition().y
	self.unitBeThrownInfo.startPos = unit:GetPosition()
	self.unitBeThrownInfo.remainDuration = duration
	local deltaHeight = endPos.y - unit:GetPosition().y
	-- 起点和落点，取最高的，加上height，为真正的最高高度
	local maxHeight
	if deltaHeight > 0 then
		maxHeight = math.max((deltaHeight + height), 0)
	else
		maxHeight = height
	end
	self.unitBeThrownInfo.max_height = maxHeight
	if maxHeight == 0 then
		self.unitBeThrownInfo.heightAccelerate = deltaHeight * 2 / (duration * duration)
		self.unitBeThrownInfo.heightSpeed = 0
	else
		local hTime = duration / (math.sqrt(1 - deltaHeight / maxHeight) + 1)
		self.unitBeThrownInfo.heightAccelerate = -2 * maxHeight / (hTime * hTime)
		self.unitBeThrownInfo.heightSpeed = -self.unitBeThrownInfo.heightAccelerate * hTime
	end
	if endRotation and rotateDuration then
		self.unitBeThrownInfo.rotateRemainDuration = rotateDuration
		self.unitBeThrownInfo.startRotation = unit:GetRotation()
	end
end

function UnitMoveComp:StopBeThrown(isEnd)
	if isEnd then
		if self.unitBeThrownInfo then
			self.unitBeThrownInfo.remainDuration = 0.02
			self:__UpdateBeThrown(0.02)
		end
		return
	end

	if self.unitBeThrownInfo and not self.unitBeThrownInfo.isNotStopAnimation and self.unitBeThrownInfo:IsHasAnimationName() then
		self.unit:StopAnimation(self.unitBeThrownInfo.animationName, 0.2)
	end

	local isBackToGround = self.unitBeThrownInfo and self.unitBeThrownInfo.isBackToGround or false
	self.unitBeThrownInfo = nil
	self.moveType = nil
	self.unit:UpdateMixedStates()

	if isBackToGround then
		---@type UnitBeThrownInfo
		local unitBeThrownInfo = UnitBeThrownInfo.New()
		unitBeThrownInfo.endPos = global.client.combat.pathManager:GetGroundPos(self.unit:GetPosition())
		unitBeThrownInfo.duration = 0.1
		unitBeThrownInfo.height = 0
		unitBeThrownInfo.isBackToGround = false
		self:BeThrown(unitBeThrownInfo)
	end
end

-- 更新beThrown
function UnitMoveComp:__UpdateBeThrown(deltaTime)
	local unit = self.unit
	self.unitBeThrownInfo.remainDuration = self.unitBeThrownInfo.remainDuration - deltaTime
	if self.unitBeThrownInfo.remainDuration <= 0 then
		self:StopBeThrown()
		return
	end
	local passedDuration = self.unitBeThrownInfo.duration - self.unitBeThrownInfo.remainDuration -- 已经运行的时间
	-- 计算高度
	local curHeight
	if self.unitBeThrownInfo.calcHeightFunc then
		curHeight = self.unitBeThrownInfo.orgHeight + self.unitBeThrownInfo.calcHeightFunc(self.unitBeThrownInfo)
	else
		curHeight = self.unitBeThrownInfo.orgHeight + self.unitBeThrownInfo.heightSpeed * passedDuration + self.unitBeThrownInfo.heightAccelerate * passedDuration * passedDuration * 0.5
	end
	-- 计算水平位置
	local interp = math.pow((1 - passedDuration / self.unitBeThrownInfo.duration), self.unitBeThrownInfo.interp)
	local new_pos = self.unitBeThrownInfo.startPos * interp + self.unitBeThrownInfo.endPos * (1 - interp)

	new_pos.y = curHeight
	unit:SetPosition(new_pos)

	if self.unitBeThrownInfo.rotateDuration and self.unitBeThrownInfo.rotateRemainDuration then
		self.unitBeThrownInfo.rotateRemainDuration = self.unitBeThrownInfo.rotateRemainDuration - deltaTime
		if self.unitBeThrownInfo.rotateRemainDuration <= 0 then
			self.unitBeThrownInfo.rotateDuration = nil
			self.unitBeThrownInfo.rotateRemainDuration = nil
			unit:SetRotation(self.unitBeThrownInfo.endRotation)
		else
			unit:SetRotation(Quaternion.Slerp(self.unitBeThrownInfo.startRotation, self.unitBeThrownInfo.endRotation, self.unitBeThrownInfo.rotateRemainDuration / self.unitBeThrownInfo.rotateDuration))
		end
	end
end
----------------------------------------------------------------------
-- LookAt相关  暂时没用
----------------------------------------------------------------------
-- 模式为lock时，可以占据LookAt， 其他地方调用LookAt将不起作用，除非mode为force强行LookAt
-- 在不需占据LookAt时，需传入unlock解锁
---@param unitOrEulerAngle Unit|Vector3
function UnitMoveComp:LookAt(unitOrEulerAngle, mode)
	self.unitLookAtInfo.isRotateXArrived = false
	self.unitLookAtInfo.isRotateYArrived = false
	if mode == "stop_look_at" then
		self.unitLookAtInfo.lookAtUnit = nil
		self.unitLookAtInfo.lookAtDir = nil
		return
	end
	if mode == "unlock" then
		self.unitLookAtInfo.isLocked = false
		return
	end
	if mode ~= "force" and self.unitLookAtInfo.isLocked then
		return
	end
	self.unitLookAtInfo.mode = mode or "idle"
	if mode == "lock" then
		self.unitLookAtInfo.isLocked = true
	end
	if unitOrEulerAngle then
		if IsUnit(unitOrEulerAngle) then
			self.unitLookAtInfo.lookAtUnit = unitOrEulerAngle
			self.unitLookAtInfo.lookAtDir = nil
		else
			self.unitLookAtInfo.lookAtDir = unitOrEulerAngle
			self.unitLookAtInfo.lookAtUnit = nil
		end
	end
end

----------------------------------------------------------------------
-- Util相关
----------------------------------------------------------------------
function UnitMoveComp:OnSpeedChange(old_value, new_value)
	local unit = self.unit
	local factor = new_value / old_value
	self.unitMoveInfo.speed = self.unitMoveInfo.speed * factor
	if self.moveType == "move" then
		self.unitMoveInfo.remainDuration = self.unitMoveInfo.remainDuration / factor
		local oldMoveAnimationSpeed = self.unitMoveInfo.animationSpeed
		self.unitMoveInfo.animationSpeed = self.unitMoveInfo.animationSpeed * factor
		if unit._graphicComponent._transform then
			unit:__MoveTo(self.unitMoveInfo.targetPos, self.unitMoveInfo.remainDuration)
			if self.unitMoveInfo:IsHasAnimationName() and self.isMoveWithMoveAnimation and
				math.abs(self.unitMoveInfo.animationSpeed - oldMoveAnimationSpeed) > 0.2 then
				unit:PlayAnimation(self.unitMoveInfo.animationName, 0.2, self.unitMoveInfo.animationSpeed)
			end
		end
	end
end

function UnitMoveComp:SetIsMoveWithMoveAnimation(isMoveWithMoveAnimation)
	local unit = self.unit
	self.isMoveWithMoveAnimation = isMoveWithMoveAnimation
	if self.moveType == "move" then
		if isMoveWithMoveAnimation then
			if self.unitMoveInfo:IsHasAnimationName() then
				unit:PlayAnimation(self.unitMoveInfo.animationName, 0, self.unitMoveInfo.animationSpeed)
			end
		else
			unit:StopAnimation(self.unitMoveInfo.animationName, 0.2)
		end
	end
end

return UnitMoveComp
--endregion
