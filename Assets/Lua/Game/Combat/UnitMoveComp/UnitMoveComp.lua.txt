---@class UnitMoveComp:TickObject
---@field _unitMoveInfo UnitMoveInfo
---@field _unitBeThrownInfo UnitBeThrownInfo
---@field _isGetCaught boolean
local UnitMoveComp = Class("UnitMoveComp", TickObject)

---@param unit Unit
function UnitMoveComp:Init(unit)
	UnitMoveComp.super.Init(self, unit)
	self._unit = unit
	self._walkStepLength = unit._cfgUnitData.walkStepLength or 1
	self._moveType = nil  -- move beThrown
	self._isMoveWithMoveAnimation = true
	self._adjustDistSqr = 3 * 3

	self._unitMoveInfo = UnitMoveInfo.New()
	self._unitMoveInfo:SetSpeed(unit:GetSpeed())
	self._unitMoveInfo:SetTargetPos(unit:GetPosition())
	self._unitMoveInfo:SetEndRotation(unit:GetRotation())
	---@type UnitLookAtInfo
	self._unitLookAtInfo = UnitLookAtInfo.New()
end

function UnitMoveComp:_Update(deltaTime, unscaledDeltaTime)
	UnitMoveComp.super._Update(self, deltaTime, unscaledDeltaTime)
	self:_UpdateMove(deltaTime)
	--if self.unitLookAtInfo:HasLookAt() then
	--  self:__UpdateLookAt(deltaTime)
	--end
	if self._unitBeThrownInfo then
		self:_UpdateBeThrown(deltaTime)
	end
end

function UnitMoveComp:_Destroy()
	UnitMoveComp.super._Destroy(self)
	self._unit = nil
end

function UnitMoveComp:OnBuild()
end

function UnitMoveComp:OnBuildOk()
	local unit = self._unit
	if self._moveType == "move" then
		if self._unitMoveInfo:IsHasAnimationName() and self._isMoveWithMoveAnimation then
			unit:PlayAnimation(self._unitMoveInfo:GetAnimationName(), 0, self._unitMoveInfo:GetAnimationSpeed())
		end
		unit:_MoveTo(self._unitMoveInfo:GetTargetPos(), self._unitMoveInfo:GetRemainDuration())
	end
end

----------------------------------------------------------------------
-- Move相关
----------------------------------------------------------------------
function UnitMoveComp:Move(targetPos, speed, animationName)
	self:MoveByPath({ targetPos }, speed, animationName)
end
function UnitMoveComp:MoveByPath(path, speed, animationName)
	local unit = self._unit
	if not unit:IsCanMove() then
		return
	end
	self._moveType = "move"
	if path[1] and not unit._isInSight then
		unit:SetPosition(path[1])
	end
	self._unitMoveInfo._path = path
	if speed then
		self._unitMoveInfo._speed = speed
	end
	if animationName then
		self._unitMoveInfo._animationName = animationName
	end
	local lastMoveAnimationSpeed = self._unitMoveInfo._animationSpeed
	self._unitMoveInfo._animationSpeed = self._unitMoveInfo._speed / self._walkStepLength
	if self._unitMoveInfo:IsHasAnimationName()
		and self._isMoveWithMoveAnimation
		and math.abs(self._unitMoveInfo._animationSpeed - lastMoveAnimationSpeed) > 0.2 then
		unit:PlayAnimation(self._unitMoveInfo._animationName, 0.2, self._unitMoveInfo._animationSpeed)
	end
	self:__MoveNextTarget(2)
end

function UnitMoveComp:__MoveNextTarget(index)
	local unit = self._unit
	if index then
		self._unitMoveInfo._targetIndexInPath = index
	else
		self._unitMoveInfo._targetIndexInPath = self._unitMoveInfo._targetIndexInPath + 1
	end
	self._unitMoveInfo._targetPos = self._unitMoveInfo._path[self._unitMoveInfo._targetIndexInPath]
	if self._unitMoveInfo._targetPos then
		local originPos = self._unitMoveInfo._path[self._unitMoveInfo._targetIndexInPath - 1]
		local distance = Vector3.Distance(self._unitMoveInfo._targetPos, originPos)
		self._unitMoveInfo._remainDuration = distance / self._unitMoveInfo._speed
		unit:_MoveTo(self._unitMoveInfo._targetPos, self._unitMoveInfo._remainDuration)
		self._unitMoveInfo._endRotation = Quaternion.LookRotation(self._unitMoveInfo._targetPos - unit:GetPosition()) or unit:GetRotation()
		self._unitMoveInfo._rotateRemainDuration = Quaternion.Angle(self._unitMoveInfo._endRotation, unit:GetRotation()) / 1080
	else
		self:MoveStop()
	end
end

function UnitMoveComp:MoveStop(rotation, pos)
	local unit = self._unit
	if pos and
		(not unit._isInSight or
			(unit._position - pos):SqrMagnitude() > self._adjustDistSqr) then
		unit:SetPosition(pos)
	end
	if rotation then
		self._unitMoveInfo._endRotation = rotation
		self._unitMoveInfo._rotateRemainDuration = Quaternion.Angle(rotation, unit._rotation) / 720
	end
	if not self._moveType then
		return
	end
	if self._moveType == "move"
		and self._isMoveWithMoveAnimation
		and self._unitMoveInfo:IsHasAnimationName() then
		if IsNotNil(unit._animation) then
			unit:StopAnimation(self._unitMoveInfo._animationName, 0.2)  -- animation动画是层叠的，停掉walk自动就播放idle
		else
			unit._animatorComp:PlayAnimation(AnimationNameConst.idle, true)
		end
	end
	self._moveType = nil
	self._unitMoveInfo._remainDuration = 0
	self._unitMoveInfo._animationSpeed = -1
	unit:StopMoveTo()
end

function UnitMoveComp:_UpdateMove(deltaTime)
	local unit = self._unit
	local deltaTimeRemainDuration = deltaTime
	while self._moveType == "move" and deltaTimeRemainDuration > 0 do
		local newPos
		if self._unitMoveInfo._remainDuration > deltaTimeRemainDuration then
			newPos = Vector3.Lerp(unit:GetPosition(), self._unitMoveInfo._targetPos, deltaTimeRemainDuration / self._unitMoveInfo._remainDuration)
			self._unitMoveInfo._remainDuration = self._unitMoveInfo._remainDuration - deltaTimeRemainDuration
			deltaTimeRemainDuration = 0
		else
			newPos = self._unitMoveInfo._targetPos
			deltaTimeRemainDuration = deltaTimeRemainDuration - self._unitMoveInfo._remainDuration
		end
		local lookDir
		if unit._unitLockTargetInfo:IsHasLockTarget() then
			lookDir = unit._unitLockTargetInfo:GetLockTargetPosition() - unit:GetPosition()
		else
			lookDir = newPos - unit:GetPosition()
		end
		unit:OnlyFaceToDir(lookDir)
		unit:SetPosition(newPos)
		if deltaTimeRemainDuration > 0 then
			self:__MoveNextTarget()
		end
	end
	if self._unitMoveInfo._lookAtUnit then
		if self._unitMoveInfo._lookAtUnit:IsDead() then
			self.lookAtUnit = nil
			return
		end
		local dir = self._unitMoveInfo._lookAtUnit:GetPosition() - unit:GetPosition()
		local angle = Vector3.Angle(unit:GetRotation():Forward(), dir)
		if angle > 5 then
			local targetRotation = Quaternion.LookRotation(dir) or unit._rotation
			unit:SetRotation(Quaternion.Slerp(unit:GetRotation(), targetRotation, 0.3))
		end
	else
		if self._unitMoveInfo._rotateRemainDuration > 0 then
			if self._unitMoveInfo._rotateRemainDuration <= deltaTime then
				unit:SetRotation(self._unitMoveInfo._endRotation)
				self._unitMoveInfo._rotateRemainDuration = 0
			else
				unit:SetRotation(Quaternion.Slerp(unit:GetRotation(), self._unitMoveInfo._endRotation, deltaTime / self._unitMoveInfo._rotateRemainDuration))
				self._unitMoveInfo._rotateRemainDuration = self._unitMoveInfo._rotateRemainDuration - deltaTime
			end
		end
	end
end


----------------------------------------------------------------------
-- beThrown相关
----------------------------------------------------------------------
---@param unitBeThrownInfo UnitBeThrownInfo
function UnitMoveComp:BeThrown(unitBeThrownInfo)
	local endPos = unitBeThrownInfo._endPos
	local duration = unitBeThrownInfo._duration
	local height = unitBeThrownInfo._height
	local endRotation = unitBeThrownInfo._endRotation
	local rotateDuration = unitBeThrownInfo._rotateDuration
	if self._moveType == "beThrown" then
		return
	end
	local unit = self._unit
	self._moveType = "beThrown"
	if unitBeThrownInfo:IsHasAnimationName() and IsNotNil(unit._animation) then
		self._unit:PlayAnimation(unitBeThrownInfo._animationName)
	end
	self._unitBeThrownInfo = unitBeThrownInfo
	self._unit:UpdateMixedStates()
	self._unitBeThrownInfo._orgHeight = unit:GetPosition().y
	self._unitBeThrownInfo.startPos = unit:GetPosition()
	self._unitBeThrownInfo._remainDuration = duration
	local deltaHeight = endPos.y - unit:GetPosition().y
	-- 起点和落点，取最高的，加上height，为真正的最高高度
	local maxHeight
	if deltaHeight > 0 then
		maxHeight = math.max((deltaHeight + height), 0)
	else
		maxHeight = height
	end
	self._unitBeThrownInfo._maxHeight = maxHeight
	if maxHeight == 0 then
		self._unitBeThrownInfo._heightAccelerate = deltaHeight * 2 / (duration * duration)
		self._unitBeThrownInfo._heightSpeed = 0
	else
		local hTime = duration / (math.sqrt(1 - deltaHeight / maxHeight) + 1)
		self._unitBeThrownInfo._heightAccelerate = -2 * maxHeight / (hTime * hTime)
		self._unitBeThrownInfo._heightSpeed = -self._unitBeThrownInfo._heightAccelerate * hTime
	end
	if endRotation and rotateDuration then
		self._unitBeThrownInfo._rotateRemainDuration = rotateDuration
		self._unitBeThrownInfo._startRotation = unit:GetRotation()
	end
end

function UnitMoveComp:StopBeThrown(isEnd)
	if isEnd then
		if self._unitBeThrownInfo then
			self._unitBeThrownInfo._remainDuration = 0.02
			self:_UpdateBeThrown(0.02)
		end
		return
	end

	if self._unitBeThrownInfo and not self._unitBeThrownInfo._isNotStopAnimation and self._unitBeThrownInfo:IsHasAnimationName() then
		self._unit:StopAnimation(self._unitBeThrownInfo._animationName, 0.2)
	end

	local isBackToGround = self._unitBeThrownInfo and self._unitBeThrownInfo._isBackToGround or false
	self._unitBeThrownInfo = nil
	self._moveType = nil
	self._unit:UpdateMixedStates()

	if isBackToGround then
		---@type UnitBeThrownInfo
		local unitBeThrownInfo = UnitBeThrownInfo.New()
		unitBeThrownInfo._endPos = global.client.combat._pathManager:GetGroundPos(self._unit:GetPosition())
		unitBeThrownInfo._duration = 0.1
		unitBeThrownInfo._height = 0
		unitBeThrownInfo._isBackToGround = false
		self:BeThrown(unitBeThrownInfo)
	end
end

-- 更新beThrown
function UnitMoveComp:_UpdateBeThrown(deltaTime)
	local unit = self._unit
	self._unitBeThrownInfo._remainDuration = self._unitBeThrownInfo._remainDuration - deltaTime
	if self._unitBeThrownInfo._remainDuration <= 0 then
		self:StopBeThrown()
		return
	end
	local passedDuration = self._unitBeThrownInfo._duration - self._unitBeThrownInfo._remainDuration -- 已经运行的时间
	-- 计算高度
	local curHeight
	if self._unitBeThrownInfo._calcHeightFunc then
		curHeight = self._unitBeThrownInfo._orgHeight + self._unitBeThrownInfo._calcHeightFunc(self._unitBeThrownInfo)
	else
		curHeight = self._unitBeThrownInfo._orgHeight + self._unitBeThrownInfo._heightSpeed * passedDuration + self._unitBeThrownInfo._heightAccelerate * passedDuration * passedDuration * 0.5
	end
	-- 计算水平位置
	local interp = math.pow((1 - passedDuration / self._unitBeThrownInfo._duration), self._unitBeThrownInfo._interp)
	local new_pos = self._unitBeThrownInfo.startPos * interp + self._unitBeThrownInfo._endPos * (1 - interp)

	new_pos.y = curHeight
	unit:SetPosition(new_pos)

	if self._unitBeThrownInfo._rotateDuration and self._unitBeThrownInfo._rotateRemainDuration then
		self._unitBeThrownInfo._rotateRemainDuration = self._unitBeThrownInfo._rotateRemainDuration - deltaTime
		if self._unitBeThrownInfo._rotateRemainDuration <= 0 then
			self._unitBeThrownInfo._rotateDuration = nil
			self._unitBeThrownInfo._rotateRemainDuration = nil
			unit:SetRotation(self._unitBeThrownInfo._endRotation)
		else
			unit:SetRotation(Quaternion.Slerp(self._unitBeThrownInfo._startRotation, self._unitBeThrownInfo._endRotation, self._unitBeThrownInfo._rotateRemainDuration / self._unitBeThrownInfo._rotateDuration))
		end
	end
end
----------------------------------------------------------------------
-- LookAt相关  暂时没用
----------------------------------------------------------------------
-- 模式为lock时，可以占据LookAt， 其他地方调用LookAt将不起作用，除非mode为force强行LookAt
-- 在不需占据LookAt时，需传入unlock解锁
---@param unitOrEulerAngle Unit|Vector3
function UnitMoveComp:LookAt(unitOrEulerAngle, mode)
	self._unitLookAtInfo._isRotateXArrived = false
	self._unitLookAtInfo._isRotateYArrived = false
	if mode == "stop_look_at" then
		self._unitLookAtInfo._lookAtUnit = nil
		self._unitLookAtInfo._lookAtDir = nil
		return
	end
	if mode == "unlock" then
		self._unitLookAtInfo._isLocked = false
		return
	end
	if mode ~= "force" and self._unitLookAtInfo._isLocked then
		return
	end
	self._unitLookAtInfo._mode = mode or "idle"
	if mode == "lock" then
		self._unitLookAtInfo._isLocked = true
	end
	if unitOrEulerAngle then
		if IsUnit(unitOrEulerAngle) then
			self._unitLookAtInfo._lookAtUnit = unitOrEulerAngle
			self._unitLookAtInfo._lookAtDir = nil
		else
			self._unitLookAtInfo._lookAtDir = unitOrEulerAngle
			self._unitLookAtInfo._lookAtUnit = nil
		end
	end
end

----------------------------------------------------------------------
-- Util相关
----------------------------------------------------------------------
function UnitMoveComp:OnSpeedChange(old_value, new_value)
	local unit = self._unit
	local factor = new_value / old_value
	self._unitMoveInfo._speed = self._unitMoveInfo._speed * factor
	if self._moveType == "move" then
		self._unitMoveInfo._remainDuration = self._unitMoveInfo._remainDuration / factor
		local oldMoveAnimationSpeed = self._unitMoveInfo._animationSpeed
		self._unitMoveInfo._animationSpeed = self._unitMoveInfo._animationSpeed * factor
		if unit._graphicComponent._transform then
			unit:_MoveTo(self._unitMoveInfo._targetPos, self._unitMoveInfo._remainDuration)
			if self._unitMoveInfo:IsHasAnimationName() and self._isMoveWithMoveAnimation and
				math.abs(self._unitMoveInfo._animationSpeed - oldMoveAnimationSpeed) > 0.2 then
				unit:PlayAnimation(self._unitMoveInfo._animationName, 0.2, self._unitMoveInfo._animationSpeed)
			end
		end
	end
end

function UnitMoveComp:SetIsMoveWithMoveAnimation(isMoveWithMoveAnimation)
	local unit = self._unit
	self._isMoveWithMoveAnimation = isMoveWithMoveAnimation
	if self._moveType == "move" then
		if isMoveWithMoveAnimation then
			if self._unitMoveInfo:IsHasAnimationName() then
				unit:PlayAnimation(self._unitMoveInfo._animationName, 0, self._unitMoveInfo._animationSpeed)
			end
		else
			unit:StopAnimation(self._unitMoveInfo._animationName, 0.2)
		end
	end
end

----------------------------------------------------------------------
-- SetGet相关
----------------------------------------------------------------------
function UnitMoveComp:GetMoveType()
	return self._moveType
end

function UnitMoveComp:SetMoveType(moveType)
	self._moveType = moveType
end

function UnitMoveComp:IsGetCaught()
	return self._isGetCaught
end

function UnitMoveComp:SetIsGetCaught(isGetCaught)
	self._isGetCaught = isGetCaught
end

function UnitMoveComp:GetUnitBeThrownInfo()
	return self._unitBeThrownInfo
end




return UnitMoveComp
--endregion
