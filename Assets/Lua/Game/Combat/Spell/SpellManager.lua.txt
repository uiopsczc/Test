---@class SpellManager:TickObject
local SpellManager = Class("SpellManager", TickObject)

function SpellManager:Init()
	SpellManager.super.Init(self)
	---@type table<string,SpellListenerInfo[]>
	self.listenerDict = {
		on_start = {}, -- 技能Start之后触发  OnSpellStart
		on_cast = {}, -- 技能OnCast之后触发  OnSpellCast
		on_hurt = {}, -- 被伤害（任何形式）  OnHurt
		on_hurt_target = {}, --  伤害目标（任何形式） OnHurt
		be_hit = {}, -- 被技能打后  OnHit
		on_hit = {}, -- 用技能打目标后  OnHit
		on_cur_spell_hit = {}, -- 用技能打目标后只有是相同的技能才触发  OnHit
		normal_attack = {}, --  放普攻后  OnHit
		before_dead = {}, --  死亡前 BeforeDead
		before_hit = {}, --  用技能打目标前  BeforeHit
		before_be_hit = {}, --  被技能打前  BeforeBeHit
		on_kill_target = {}, -- 杀死目标后 OnKillTarget
		on_hp_change = {}, -- 目标血量改变时 OnHpChange
		on_missile_reach = {}, -- 当子弹到达
	}

	self:AddListener(SpellEventNameConst.On_Spell_Start, function(...)
		self:OnSpellStart(...)
	end) --
	self:AddListener(SpellEventNameConst.On_Spell_Cast, function(...)
		self:OnSpellCast(...)
	end) --
	self:AddListener(SpellEventNameConst.On_Missile_Reach, function(...)
		self:OnMissileReach(...)
	end)
	self:AddListener(UnitEventNameConst.On_Unit_Hp_Change, function(...)
		self:OnHpChange(...)
	end)
	self:AddListener(UnitEventNameConst.On_Unit_Hurt, function(...)
		self:OnHurt(...)
	end)
	self:AddListener(UnitEventNameConst.Before_Unit_Dead, function(...)
		self:BeforeDead(...)
	end)
	self:AddListener(UnitEventNameConst.On_Unit_Kill_Target, function(source_unit, target_unit, spell, ...)
		if spell then
			self:OnKillTarget(...)
		end
	end)
	self:AddListener(UnitEventNameConst.On_Unit_Hit, function(...)
		self:OnHit(...)
	end) --
	self:AddListener(UnitEventNameConst.Before_Unit_Hit, function(...)
		self:BeforeHit(...)
	end) --

	self:AddListener(UnitEventNameConst.On_Unit_Destroy, function(...)
		self:OnUnitDestroy(...)
	end) --
end

----------------------------------------------------------------------
-- 释放技能相关
----------------------------------------------------------------------
---@param sourceUnit Unit
---@param targetUnit Unit
---@param isControl @是否控制类技能
function SpellManager:CastSpell(sourceUnit, spellId, targetUnit, argDict, isControl)
	local isCanCast, cfgSpellData, spellClass = self:CheckIsCanCast(sourceUnit, spellId, targetUnit, isControl)
	if not isCanCast then
		return false
	end
	-- 开始释放技能
	---@type SpellBase
	local spell = self:AddChild(nil, spellClass, sourceUnit, spellId, targetUnit, cfgSpellData, argDict)
	if cfgSpellData.castType == "正常" then
		-- 当玩家是手动操作释放技能时，技能方向就以玩家的输入为准（但如果有目标则会以目标方向释放技能，无视输入）
		-- 当释放的技能类型是正常的话，则需停下来施法
		if sourceUnit.currentAttack then
			self:BreakSpell(sourceUnit.currentAttack:GetGuid())
		end
		local rotation = nil
		local isNotFaceToTarget = argDict and argDict.isNotFaceToTarget
		isNotFaceToTarget = isNotFaceToTarget or cfgSpellData.isNotFaceToTarget
		local targetPosition = argDict and argDict.position or targetUnit:GetPosition()
		if targetUnit and (not isNotFaceToTarget or not isControl) then
			local dir = targetPosition - sourceUnit:GetPosition()
			rotation = Quaternion.LookRotation(dir)
			if rotation then
				sourceUnit:FaceTo(rotation)
			end
		end
		if not cfgSpellData.isCanMoveWhileCast or not isControl then
			sourceUnit:MoveStop(rotation)
		end
		sourceUnit.currentAttack = spell
		sourceUnit:UpdateMixedStates()
	end
	if cfgSpellData.type == "普攻" then
		sourceUnit:NormalAttackStart()
	end
	spell:Start()
	return true
end

---@param sourceUnit Unit
---@param targetUnit Unit
---@return boolean, CfgSpellData
function SpellManager:CheckIsCanCast(sourceUnit, spellId, targetUnit, isControl)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	if not cfgSpellData then
		ErrorFormat("spell_id(%d) is not exist!", spellId)
		return false
	end
	if not sourceUnit or (sourceUnit:IsDead() and cfgSpellData.castType ~= "触发") then
		return false
	end
	if not sourceUnit:IsSpellCoolDownOk(spellId) then
		return false
	end
	if not sourceUnit:CanBreakCurrentSpell(spellId, cfgSpellData) then
		return false
	end

	local scope = cfgSpellData.targetType or "enemy"
	--   如果是混乱则找任何可以攻击的人
	if sourceUnit:IsConfused() then
		scope = "all"
	end
	local isOnlyAttackable = scope ~= "friend"
	if cfgSpellData.isNeedTarget then
		if not targetUnit then
			return false
		end
		if not global.client.combat.unitManager:__CheckUnit(targetUnit, sourceUnit, { mode = "circle", radius = cfgSpellData.range }, sourceUnit:GetFaction(), scope, isOnlyAttackable) then
			return false
		end
	end
	local spellClass = ClassLoadUtil.Load(cfgSpellData.class_path_lua)
	if spellClass.CheckIsCanCast and
		not spellClass.CheckIsCanCast(sourceUnit, spellId, targetUnit, cfgSpellData, isControl) then
		return false
	end
	return true, cfgSpellData, spellClass
end


--  RecommendCast的作用：按照技能的作用对象、偏好，返回一堆按顺序排好的推荐目标
---@param sourceUnit Unit
---@param targetUnitList Unit[]|Unit
---@return Unit[]
function SpellManager:RecommendCast(sourceUnit, spellId, targetUnitList, isControl)
	if not sourceUnit or sourceUnit:IsDead() then
		return {}
	end
	if not targetUnitList then
		return {}
	end
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	local spellClass = ClassLoadUtil.Load(cfgSpellData.classPathLua)
	if not spellClass then
		Error("spell code is not exist: ", cfgSpellData.classPathLua)
		return {}
	end
	if targetUnitList and IsUnit(targetUnitList) then
		local targetUnit = targetUnitList
		if self:__IsUnitMatchCondition(sourceUnit, targetUnit, isControl, cfgSpellData, spellClass) then
			return { targetUnit }
		end
	end
	local newTargetUnitList = {}
	for _, target in ipairs(targetUnitList) do
		if self:__IsUnitMatchCondition(sourceUnit, target, isControl, cfgSpellData, spellClass) then
			table.insert(newTargetUnitList, target)
		end
	end
	return self:RecommendSpellRule(sourceUnit, newTargetUnitList[1], cfgSpellData, sourceUnit:GetPosition(), newTargetUnitList)
end

---@param cfgSpellData CfgSpellData
---@param sourceUnit Unit
---@param targetUnit Unit
---@param targetUnitList Unit[]
function SpellManager:RecommendSpellRule(sourceUnit, targetUnit, cfgSpellData, originPosition, targetUnitList)
	--当前敌人
	--随机x个敌人
	--生命最低的x个人敌人
	--全体敌人
	--自己
	--随机x个队友
	--生命最低的x个队友
	--全体队友
	--召唤单位
	--场上所有人(不分敌友)
	if not targetUnit then
		return {}
	end
	local selectUnitArgDict = cfgSpellData.select_unit_arg_dict
	if not selectUnitArgDict then
		return targetUnitList or { targetUnit }
	end

	local selectUnitFaction = selectUnitArgDict.selectUnitFaction
	local selectUnitCount = selectUnitArgDict.selectUnitCount or 1000
	local scope = SpellConst.Select_Unit_Faction_Dict[selectUnitFaction]

	-- 这个技能的初始点
	local conditionDict = {
		order = "distance",
		origin = originPosition,
		faction = sourceUnit:GetFaction(),
		scope = scope,
		rangeInfo = { mode = "circle", radius = cfgSpellData.range }
	}
	targetUnitList = targetUnitList or global.client.combat.unitManager:SelectUnit(conditionDict)

	local count = selectUnitCount
	local newTargetList = {}
	--TODO select_unit
	--TODO select_unit
	newTargetList = table.Sub_Array(targetUnitList, nil, nil, count)
	if #newTargetList == 0 then
		return { targetUnit }
	end

	return newTargetList
end


-- 检查单位是否符合需求
---@param sourceUnit Unit
---@param cfgSpellData CfgSpellData
---@param targetUnit Unit
function SpellManager:__IsUnitMatchCondition(sourceUnit, targetUnit, isControl, cfgSpellData, spellClass)
	--肯定有target
	if targetUnit:IsDead() then
		return false
	end
	if not sourceUnit:IsConfused() then
		if cfgSpellData.targetType == "enemy" and targetUnit:IsInvincible() then
			return false
		end
		if cfgSpellData.targetType and cfgSpellData.targetType ~= "all" then
			if not global.client.combat.unitManager:CheckFaction(sourceUnit:GetFaction(), targetUnit:GetFaction(), cfgSpellData.targetType) then
				return false
			end
		end
	end
	if not spellClass.IsUnitMatchCondition(sourceUnit, cfgSpellData.id, targetUnit, cfgSpellData, isControl) then
		return false
	end
	return true
end

----------------------------------------------------------------------
-- 监听回调技能相关
----------------------------------------------------------------------
---@param type string
---@param unit Unit
function SpellManager:RegisterListener(type, unit, obj, tag, func)
	if not self.listenerDict[type] then
		Error("Register Listener with undefine type()!", type)
		return
	end
	---@type SpellListenerInfo
	local spellListenerInfo = SpellListenerInfo.New()
	spellListenerInfo.type = type
	spellListenerInfo.unit = unit
	spellListenerInfo.obj = obj
	spellListenerInfo.tag = tag
	spellListenerInfo.func = func
	table.insert(self.listenerDict[type], spellListenerInfo)
end

---@param type string
---@param unit Unit
function SpellManager:UnRegisterListener(type, unit, obj, tag)
	if not self.listenerDict[type] then
		ErrorFormat("Unregister Listener with undefine type(%s)!", type)
		return
	end
	for index, listenerInfo in ipairs(self.listenerDict[type]) do
		if listenerInfo.unit == unit and
			listenerInfo.obj == obj and
			listenerInfo.tag == tag then
			table.remove(self.listenerDict[type], index)
			break
		end
	end
end

function SpellManager:RemoveListenersByObj(obj)
	for _, listeners in pairs(self.listenerDict) do
		for i = #listeners, 1, -1 do
			if listeners[i].obj == obj then
				table.remove(listeners, i)
			end
		end
	end
end

---@param listener SpellListenerInfo
function SpellManager:ListenerCallback(listener, sourceUnit, ...)
	listener.func(sourceUnit, ...)
end

function SpellManager:BeforeHit(sourceUnit, targetUnit, ...)
	for k, listener in ipairs(self.listenerDict.beforeHit) do
		if listener.unit == sourceUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, ...)
		end
	end
	for k, listener in ipairs(self.listenerDict.before_be_hit) do
		if listener.unit == targetUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, ...)
		end
	end
end

---@param spell SpellBase
function SpellManager:OnHit(sourceUnit, targetUnit, spell, ...)
	for k, listener in ipairs(self.listenerDict.be_hit) do
		if listener.unit == targetUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell, ...)
		end
	end
	-- !注意：触发回调的过程中可能再次插入或者remove listener
	for k, listener in ipairs(self.listenerDict.on_hit) do
		if listener.unit == sourceUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell, ...)
		end
	end
	for k, listener in ipairs(self.listenerDict.on_cur_spell_hit) do
		if listener.unit == sourceUnit and spell == listener.obj then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell, ...)
		end
	end
	if spell.cfgSpellData.type == "普攻" then
		for k, listener in ipairs(self.listenerDict.normal_attack) do
			if listener.unit == sourceUnit then
				self:ListenerCallback(listener, sourceUnit, targetUnit, spell, ...)
			end
		end
	end
end

function SpellManager:OnKillTarget(sourceUnit, targetUnit, spell, ...)
	for k, listener in ipairs(self.listenerDict.on_kill_target) do
		if listener.unit == sourceUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell, ...)
		end
	end
end

function SpellManager:BeforeDead(sourceUnit, deadUnit, ...)
	for k, listener in ipairs(self.listenerDict.before_dead) do
		if listener.unit == deadUnit then
			self:ListenerCallback(listener, sourceUnit, deadUnit, ...)
		end
	end
end

function SpellManager:OnHurt(sourceUnit, targetUnit, ...)
	for k, listener in ipairs(self.listenerDict.on_hurt) do
		if listener.unit == targetUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, ...)
		end
	end
	for k, listener in ipairs(self.listenerDict.on_hurt_target) do
		if listener.unit == sourceUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, ...)
		end
	end
end

function SpellManager:OnHpChange(sourceUnit, targetUnit, ...)
	for k, listener in ipairs(self.listenerDict.on_hp_change) do
		if listener.unit == targetUnit then
			self:ListenerCallback(listener, sourceUnit, targetUnit, ...)
		end
	end
end

function SpellManager:OnSpellStart(sourceUnit, targetUnit, spell)
	for k, listener in ipairs(self.listenerDict.on_start) do
		if listener.unit == sourceUnit and listener.obj == spell then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell)
		end
	end
end

function SpellManager:OnSpellCast(sourceUnit, targetUnit, spell)
	for k, listener in ipairs(self.listenerDict.on_cast) do
		if listener.unit == sourceUnit and listener.obj == spell then
			self:ListenerCallback(listener, sourceUnit, targetUnit, spell)
		end
	end
end

function SpellManager:OnMissileReach(sourceUnit, missile, spell)
	for k, listener in ipairs(self.listenerDict.on_missile_reach) do
		if listener.unit == sourceUnit and listener.obj == spell then
			self:ListenerCallback(listener, sourceUnit, missile, spell)
		end
	end
end

----------------------------------------------------------------------
-- Util相关
----------------------------------------------------------------------

---@return SpellBase
function SpellManager:GetSpell(guid)
	return self:GetChild(guid)
end

function SpellManager:BreakSpell(guid)
	local spell = self:GetSpell(guid)
	if spell then
		spell:Break()
	end
end

function SpellManager:RemoveSpell(guid)
	self:RemoveChild(guid)
end

function SpellManager:OnUnitDestroy(unit)
	if unit.current_attack then
		self:BreakSpell(unit.current_attack:GetGuid())
	end
end

function SpellManager:GetSpellRange(spellId)
	local cfgSpellData = CfgSpell.get_by_id(spellId)
	if not cfgSpellData then
		ErrorFormat("spell_id(%s) is not exist!", spellId)
		return false
	end
	local argDict = cfgSpellData.arg_dict or {}
	local minRange = DoerAttrParserUtil.ConvertValueWithTypeString(argDict.minRange)
	return cfgSpellData.range, minRange
end

---@param spell SpellBase
function SpellManager:OnSpellAnimationFinished(spell)
	if spell.sourceUnit.currentAttack == spell then
		if spell.sourceUnit.isNormalAttacking then
			spell.sourceUnit:NormalAttackFinish()
		end
		spell.sourceUnit.currentAttack = nil
		spell.sourceUnit:UpdateMixedStates()
	end
end

return SpellManager