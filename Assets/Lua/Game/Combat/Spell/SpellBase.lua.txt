---@class SpellBase:TickObject
local SpellBase = Class("SpellBase", TickObject)

---@param sourceUnit Unit
---@param targetUnit Unit
---@param cfgSpellData CfgSpellData
function SpellBase:Init(sourceUnit, spellId, targetUnit, cfgSpellData, instanceArgDict)
	SpellBase.super.Init(self)
	self.sourceUnit = sourceUnit
	self.targetUnit = targetUnit
	self.spellId = spellId
	self.cfgSpellData = cfgSpellData
	self.instanceArgDict = instanceArgDict

	self.originPosition = instanceArgDict.originPosition or self.sourceUnit:GetPosition()
	self.transmitArgDict = instanceArgDict.transmitArgDict or {}
	self.attackDir = self.transmitArgDict.attackDir
	self.newSpellTriggerId = self.transmitArgDict.newSpellTriggerId  -- 通过哪个trigger_id启动的技能

	self.argDict = DoerAttrParserUtil.ConvertTableWithTypeString(cfgSpellData.argDict)
	self.isCanMoveWhileCast = self.cfgSpellData.isCanMoveWhileCast
	self.isSpellAnimationFinished = self.cfgSpellData.castType == "触发"
	self.animationEventList = {}

	if self.isCanMoveWhileCast and self.sourceUnit and not self.sourceUnit:IsDead() then
		self.sourceUnit:SetIsMoveWithMoveAnimation(false)
	end
	self.sourceUnit:SetSpellInfoCoolDown(self.spellId, 1)
	self:InitCounter()
end

function SpellBase:AddCombatNumber(number, targetUnitGuid, maxType, param)
end

function SpellBase:AddCombatImage(immuneType, targetGuid)
end

function SpellBase:AddCombatText(strInfo, targetGuid)
end

----------------------------------------------------------------------
-- 伤害相关
----------------------------------------------------------------------
-- damage_factor是伤害倍率
---@param sourceUnit Unit
---@param targetUnit Unit
---@param damageFactor number
---@param forceDamageValue number
---@param is_ignore_reduce boolean
function SpellBase:___Hit(sourceUnit, targetUnit, damageFactor, forceDamageValue)
	if not targetUnit or targetUnit:IsDead() then
		return
	end
	self:CreateHitEffect(sourceUnit, targetUnit)
	local damageValue, specialEffectDict = self:TakeDamage(sourceUnit, targetUnit, damageFactor, forceDamageValue)
	self:Broadcast(UnitEventNameConst.On_Unit_Hit, sourceUnit, targetUnit, self, damageValue)
	self:AddCombatNumber(damageValue, targetUnit:GetGuid(), "physical", specialEffectDict)
	targetUnit:PlayAnimation(AnimationNameConst.beHit, nil, nil, nil, true)
	return damageValue
end

---@param sourceUnit Unit
---@param targetUnit Unit
---@param damageFactor number
---@param forceDamageValue number
function SpellBase:Hit(sourceUnit, targetUnit, damageFactor, forceDamageValue)
	self:___Hit(sourceUnit, targetUnit, damageFactor, forceDamageValue)
end

---@param sourceUnit Unit
---@param targetUnit Unit
---@param damageFactor number
---@param forceDamageValue number
---@param is_ignore_reduce boolean
function SpellBase:TakeDamage(sourceUnit, targetUnit, damageFactor, forceDamageValue)
	if not targetUnit or targetUnit:IsDead() then
		return
	end
	local specialEffectDict = {}

	damageFactor = (damageFactor and damageFactor > 0 and damageFactor) or self.cfgSpellData.damageFactor or 1
	-- 计算原始伤害值
	local damageValue = forceDamageValue
	if not forceDamageValue then
		damageValue, specialEffectDict = sourceUnit.propertyComp:CalculateOriginalDamageValue({ damageFactor = damageFactor,
																								curHpPct = sourceUnit:GetHp() / sourceUnit:GetMaxHp() })
		--计算减伤
		damageValue = sourceUnit.propertyComp:CalculateRealDamageValue(damageValue, targetUnit)
	end
	--伤害前的回调
	self:Broadcast(UnitEventNameConst.Before_Unit_Hit, sourceUnit, targetUnit, self, damageValue)
	-- 目标接收伤害
	damageValue = targetUnit:TakeDamage(damageValue, sourceUnit, self)
	return damageValue, specialEffectDict
end

---@param targetUnit Unit
---@param sourceUnit Unit
function SpellBase:Heal(sourceUnit, targetUnit, forceHealValue, healFactor)
	targetUnit = targetUnit or self.targetUnit
	sourceUnit = sourceUnit or self.sourceUnit
	local specialEffectDict = {}
	if not targetUnit or targetUnit:IsDead() then
		return
	end
	healFactor = healFactor or self.cfgSpellData.damageFactor or 1
	local healValue
	if forceHealValue then
		healValue = forceHealValue
	else
		healValue, specialEffectDict = sourceUnit.propertyComp:CalculateOriginalHealValue({
			healFactor = healFactor,
			damageType = self.cfgSpellData.damageType
		})
		healValue = sourceUnit.propertyComp:CalculateRealHealValue(healValue, targetUnit)
	end
	targetUnit:Heal(healValue, sourceUnit)
	return healValue, specialEffectDict
end

-- 吸血,不能吸建筑
-- 一定要传force_heal_count
function SpellBase:SuckBlood(sourceUnit, targetUnit, forceHealValue)
	self:Heal(sourceUnit, targetUnit, forceHealValue)
end


----------------------------------------------------------------------
-- Counter相关
----------------------------------------------------------------------
function SpellBase:InitCounter()
	---@type Counter
	self.counter = Counter.New()
	self.counter:AddChangeValueInvokeFunc(function()
		self:__CounterFunc()
	end)
end

function SpellBase:__CounterFunc()
	if self.counter._count < 0 then
		Error("counter.count < 0")
	end
	if self.counter._count == 0 and self.isSpellAnimationFinished and not self:IsDestroyed() then
		self:RemoveSelf()
	end
end

function SpellBase:CounterIncrease()
	self.counter:Increase()
end

function SpellBase:CounterDecrease()
	self.counter:Decrease()
end

----------------------------------------------------------------------
-- 流程相关
----------------------------------------------------------------------
-- 技能起手处理
function SpellBase:Start()
	if self.cfgSpellData.type == "被动" then
		self:CounterIncrease()  -- 被动默认不被消耗
	end
	self:CounterIncrease()
	self.targetUnitList = global.client.combat.spellManager:RecommendSpellRule(self.sourceUnit, self.targetUnit, self.cfgSpellData, self.originPosition)
	self.targetUnit = self.targetUnitList[1]
	if self.OnStart then
		self:OnStart()
	end
	self:RegisterTriggerSpell()
	self:Broadcast(SpellEventNameConst.On_Spell_Start, self.sourceUnit, self.targetUnit, self)
	global.client.combat.spellManager:UnRegisterListener("on_start", self.sourceUnit, self, "RegisterTriggerSpell")
	if self.cfgSpellData.actionName then
		if not self.sourceUnit.actionDict or
			not self.sourceUnit.actionDict[self.cfgSpellData.actionName] then
			Error("action is not find", self.spellId, self.sourceUnit.unitId)
		end
		self.action = SpellAction.New(self.sourceUnit.actionDict[self.cfgSpellData.actionName], self.sourceUnit, self)
		self.action:Play()
	else
		self:PlaySpellAnimation()
		if self.OnCast then
			-- 起手前摇
			self:RegisterAnimationEvent(self:GetAnimationTimePct(self.cfgSpellData.castTime) or 0, "__OnCast")
		end
		-- 可打断后摇
		self:RegisterAnimationEvent(self:GetAnimationTimePct(self.cfgSpellData.breakTime) or 1, "PassBreakTime")
		if self.cfgSpellData.castType ~= "触发" then
			if (self:GetAnimationTimePct(self.cfgSpellData.breakTime) or 1) < (self:GetAnimationTimePct(self.cfgSpellData.castTime) or 0) then
				Error("技能脱手时间比出手时间快")
			end
			self:RegisterAnimationEvent(self:GetAnimationTimePct(self.cfgSpellData.breakTime) or 1, "OnSpellAnimationFinished")
		end
	end
	self:CounterDecrease()
end

function SpellBase:GetAnimationTimePct(time)
	if self.cfgSpellData.animationDuration then
		if time then
			return time / self.cfgSpellData.animationDuration
		end
	end
end

function SpellBase:__OnCast()
	if self.OnCast then
		self:OnCast()
	end
	self:Broadcast(SpellEventNameConst.On_Spell_Cast, self.sourceUnit, self.targetUnit, self)
	global.client.combat.spellManager:UnRegisterListener("on_cast", self.sourceUnit, self, "RegisterTriggerSpell")
end

function SpellBase:RegisterTriggerSpell()
	-- 注册表里填的技能触发事件，由简单的技能按顺序触发组成复杂的技能
	local newSpellTriggerIds = self.cfgSpellData.newSpellTriggerIds
	if not newSpellTriggerIds then
		return
	end
	for k, v in ipairs(newSpellTriggerIds) do
		self:__RegisterTriggerSpell(v)
	end
end

function SpellBase:__RegisterTriggerSpell(newSpellTriggerId)
	local cfgSpellTriggerData = CfgSpellTrigger.get_by_id(newSpellTriggerId)
	local triggerType = cfgSpellTriggerData.trigger_type
	triggerType = SpellConst.Trigger_Type_Dict[triggerType]
	local triggerSpellId = cfgSpellTriggerData.triggerSpellId -- 触发的技能id
	local triggerSpellDelayDuration = cfgSpellTriggerData.triggerSpellDelayDuration
	global.client.combat.spellManager:RegisterListener(triggerType, self.sourceUnit, self, "RegisterTriggerSpell", function(sourceUnit, targetUnit, spell)
		-- 这里可以添加是否满足其它触发条件判断
		if not self:CheckTriggerCondition(cfgSpellTriggerData, sourceUnit, targetUnit) then
			return
		end
		local triggerArgDict = {}
		triggerArgDict.sourceSpell = self
		triggerArgDict.transmitArgDict = self:GetTransmitArgDict()
		triggerArgDict.triggerId = newSpellTriggerId
		local triggerFunc = function()
			-- 启动技能时需要把新技能需要的参数传进去，如果当前技能没有提供这样的方法，则说明当前技能不能启动目标技能
			global.client.combat.spellManager:CastSpell(self.sourceUnit, triggerSpellId, targetUnit, triggerArgDict)
		end
		if triggerSpellDelayDuration then
			self:CounterIncrease()
			self:AddTimer(function()
				triggerFunc()
				self:CounterDecrease()
			end, nil, triggerSpellDelayDuration)
		else
			triggerFunc()
		end
	end)
end

function SpellBase:CheckTriggerCondition(cfgSpellTriggerData, sourceUnit, targetUnit)
	return true
end

-- 需要解决的问题，比如一个技能同时攻击了几个单位，触发了几次on_hit，怎么在回调中知道这个hit是由哪次攻击造成的
-- 定义几种参数类型
--[=[
  SpellBase提供默认参数，具体技能根据自己实际情况重写
  1.攻击方向
  2.技能基础位置
]=]
--------------------------传递给下一个技能的方法 -------------------------
function SpellBase:GetTransmitArgDict()
	return {
		originPosition = self:GetOriginPosition(),
		attackDir = self:GetAttackDir(),
	}
end

function SpellBase:GetOriginPosition()
	return self.originPosition or self.sourceUnit:GetPosition()
end

function SpellBase:GetAttackDir()
	return Vector3.zero
end

function SpellBase:SwitchAction(action_name)
	self.action = SpellAction.New(self.sourceUnit.actionDict[action_name], self.sourceUnit, self)
	self.action:Play()
end

function SpellBase:__Update(deltaTime, unscaledDeltaTime)
	SpellBase.super.__Update(self, deltaTime, unscaledDeltaTime)
	if not self.isSpellAnimationFinished then
		-- 脱手了就不需要执行动画了
		if self.action then
			self.action:Update(deltaTime)
		else
			self:ProcessAnimationEvent(deltaTime)
		end
	elseif self.cfgSpellData.castType == "触发" then
		self:ProcessAnimationEvent(deltaTime)
	end
end


-- 技能脱手，表示角色释放技能完成，可以做其他动作，但是技能本身可能没有完成，继续运行
-- 比如脱手后子弹任然要飞，打到人才真正结束
-- 使用CounterIncrease()和CounterDecrease()计数来控制真正结束
function SpellBase:OnSpellAnimationFinished()
	if self.isSpellAnimationFinished then
		return
	end
	self.isSpellAnimationFinished = true
	global.client.combat.spellManager:OnSpellAnimationFinished(self)
	if self.counter._count <= 0 then
		self:RemoveSelf()
	end
	if self.cfgSpellData.isCanMoveWhileCast and self.sourceUnit and not self.sourceUnit:IsDead() then
		self.sourceUnit:SetIsMoveWithMoveAnimation(true)
	end
end

function SpellBase:Break()
	self:StopSpellAnimation()
	self:OnSpellAnimationFinished()
end

-- 子类添加 FilterUnit 函数可以自定义过滤掉不需要的目标
function SpellBase:FilterUnit(unit, spell_id, target_unit, cfgSpellData)
	return true
end

---@param missileEffect MissileEffect
function SpellBase:OnMissileReach(missileEffect)
	self:Broadcast(SpellEventNameConst.On_Missile_Reach, self.sourceUnit, missileEffect, self)
	self:CounterDecrease()
end

----------------------------------------------------------------------
-- 动画相关
----------------------------------------------------------------------
function SpellBase:PlaySpellAnimation(faceToPosition)
	if self.cfgSpellData.animationDuration then
		self.__animationTimePct = 0
		self.__animation_start_time = CombatUtil.GetTime()
	end
	if self.cfgSpellData.animationName then
		if not faceToPosition and self.targetUnit then
			faceToPosition = self.targetUnit:GetPosition()
		end
		-- 不转向
		if self.cfgSpellData.isNotFaceToTarget then
			faceToPosition = nil
		end
		local speed = (self.cfgSpellData.type == "普攻" and self.sourceUnit:GetCalcPropValue("攻击速度") or 1)
		self.sourceUnit:PlayAnimation(self.cfgSpellData.animationName, nil, speed, faceToPosition, self.cfgSpellData.isCanMoveWhileCast)
	end
end

function SpellBase:StopSpellAnimation()
	if self.cfgSpellData.animationName then
		self.sourceUnit:StopAnimation(self.cfgSpellData.animationName)
	end
end

-- 注意：只能在start时调用，不能在事件中调用
function SpellBase:RegisterAnimationEvent(timePct, invokeMethodName, argDict)
	if not self.cfgSpellData.animationDuration or not timePct or timePct <= 0 then
		self[invokeMethodName](self, argDict)
		return
	end
	local newEvent = { timePct = timePct, eventName = invokeMethodName, argDict = argDict }
	for k, animationEvent in ipairs(self.animationEventList) do
		if animationEvent.timePct > timePct then
			table.insert(self.animationEventList, k, newEvent)
			return
		end
	end
	table.insert(self.animationEventList, newEvent)
end

function SpellBase:ProcessAnimationEvent(deltaTime)
	if not self.__animationTimePct then
		return
	end
	self.__animationTimePct = self.__animationTimePct + deltaTime / (self.cfgSpellData.animationDuration / (1 + self.sourceUnit:GetCalcPropValue("攻击速度")))
	while true do
		local animationEvent = self.animationEventList[1]
		-- 没有animation_event了
		if not animationEvent then
			return
		end
		-- 还没触发
		if animationEvent.timePct > self.__animationTimePct then
			return
		end
		-- 时间到，可以进行触发
		table.remove(self.animationEventList, 1)
		self[animationEvent.invokeMethodName](self, animationEvent.argDict)
	end
end

function SpellBase:PassBreakTime()
	self.isPastBreakTime = true
	self.sourceUnit:UpdateMixedStates()
end
----------------------------------------------------------------------
-- Buff相关
----------------------------------------------------------------------
---@param targetUnit Unit
---@param forceDuration number
function SpellBase:AddBuff(buffId, targetUnit, forceDuration, argDict)
	if not buffId then
		return
	end
	if not targetUnit or targetUnit:IsDead() then
		return
	end
	argDict = argDict or {}
	argDict.sourceSpell = self
	targetUnit.buffManager:AddBuff(buffId, self.sourceUnit, forceDuration, argDict)
end

--  移除传入具体的buff
---@param unit Unit
---@param buffList Buff[]
function SpellBase:RemoveBuff(buffList, unit)
	if not buffList then
		return
	end
	unit = unit or self.sourceUnit
	for _, buff in ipairs(buffList) do
		unit.buffManager:RemoveBuff(buff.buffId, nil, self:GetGuid())
	end
end

---@param unit Unit
function SpellBase:RemoveBuffById(buffIdList, unit, forceSpellGuid)
	if not unit or unit:IsDead() then
		return
	end
	if IsString(buffIdList) then
		local buffId = buffIdList
		unit.buffManager:RemoveBuff(buffId, self.sourceUnit:GetGuid(), forceSpellGuid or self:GetGuid())
	elseif buffIdList then
		for _, buffId in ipairs(buffIdList) do
			unit.buffManager:RemoveBuff(buffId, self.sourceUnit:GetGuid(), forceSpellGuid or self:GetGuid())
		end
	end
end

----------------------------------------------------------------------
-- Effect相关
----------------------------------------------------------------------
-- 起手特效
function SpellBase:CreateHandEffect(duration)
	if not self.cfgSpellData.handEffectIds then
		return
	end
	local effectIds, guidList = self.cfgSpellData.handEffectIds, {}
	for _, effectId in ipairs(effectIds) do
		local effect = global.client.combat.effectManager:CreateAttachEffect(effectId, self.sourceUnit, duration)
		table.insert(guidList, effect:GetGuid())
	end
	return guidList
end

-- 出手特效
function SpellBase:CreateGoEffect(duration)
	if not self.cfgSpellData.goEffectIds then
		return
	end
	local effectIds, guidList = self.cfgSpellData.goEffectIds, {}
	for _, effectId in ipairs(effectIds) do
		local effect = global.client.combat.effectManager:CreateAttachEffect(effectId, self.sourceUnit, duration)
		table.insert(guidList, effect:GetGuid())
	end
	return guidList
end

-- 击中特效
function SpellBase:CreateHitEffect(sourceUnit, targetUnit, duration, sectorAngle, forceEffectIdList)
	if not self.cfgSpellData.hitEffectIds and not forceEffectIdList then
		return
	end
	local forceDir
	if sourceUnit then
		---@type Quaternion
		local forceRotation = Quaternion.LookRotation(targetUnit:GetPosition() - sourceUnit:GetPosition())
		forceDir = forceRotation and forceRotation:ToEulerAngles() or nil
	end
	local effectIds, guidList = forceEffectIdList or self.cfgSpellData.hitEffectIds, {}

	for _, effectId in ipairs(effectIds) do
		local effect = global.client.combat.effectManager:CreateAttachEffect(effectId, self.sourceUnit, duration, forceDir, sectorAngle)
		table.insert(guidList, effect:GetGuid())
	end
	return guidList
end

-- 地面特效
function SpellBase:CreateGroundEffect(position, eulerAngles, duration, forceEffectIds, forcePosition, isHide)
	if not self.cfgSpellData.ground_effect_ids and not forceEffectIds then
		return
	end
	position = forcePosition or position or self.sourceUnit:GetPosition()
	eulerAngles = eulerAngles or QuaternionUtil.GetValueOrDefault(Quaternion.LookRotation(position - self.sourceUnit:GetPosition())):ToEulerAngles()
	local effectIds, guidList = forceEffectIds or self.cfgSpellData.ground_effect_ids, {}
	if not forcePosition then
		position = global.client.combat.pathManager:GetGroundPos(position)
	end
	for _, effectId in ipairs(effectIds) do
		local effect = global.client.combat.effectManager:CreateGroundEffect(effectId, self.sourceUnit, position, eulerAngles, duration, isHide)
		table.insert(guidList, effect:GetGuid())
	end
	return guidList
end

-- line特效
function SpellBase:CreateLineEffect(target, speed, accSpeed)
	if not target or (IsUnit(target) and target:IsDead()) then
		return {}
	end
	local effectIds, guids = self.cfgSpellData.lineEffectIds, {}
	for _, effectId in ipairs(effectIds) do
		local guid = global.client.combat.effectManager:CreateLineEffect(effectId, self.sourceUnit, self.sourceUnit, target, speed, accSpeed)
		table.insert(guids, guid)
	end
	return guids
end

function SpellBase:RemoveEffect(effectGuidList)
	if not effectGuidList then
		return
	end
	if IsString(effectGuidList) then
		local effectGuid = effectGuidList
		global.client.combat.effectManager:RemoveEffectEntity(effectGuid)
	else
		for _, effectGuid in ipairs(effectGuidList) do
			global.client.combat.effectManager:RemoveEffectEntity(effectGuid)
		end
	end
end

---------------------------------------------------------------
function SpellBase:RemoveSelf()
	global.client.combat.spellManager:RemoveSpell(self:GetGuid())
end

function SpellBase:_Destroy()
	SpellBase.super.__Destroy(self)
	if not self.isSpellAnimationFinished then
		global.client.combat.spellManager:OnSpellAnimationFinished(self)
	end
	global.client.combat.spellManager:RemoveListenersByObj(self)
end

return SpellBase