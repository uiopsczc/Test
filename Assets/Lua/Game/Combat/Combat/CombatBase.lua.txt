---@class CombatBase:TickObject
---@field time number
local CombatBase = Class("CombatBase", TickObject)

function CombatBase:Init(arg_dict)
	CombatBase.super.Init(self)
	self.argDict = arg_dict or {}
	self.isFixedDurationUpdate = true

	---@type RandomManager
	self.randomManager = RandomManager.New(arg_dict["random_seed"])
	---@type TimerManager
	self.timerManager = TimerManager.New()

	---@type EffectManager
	self.effectManager = self:AddChild("EffectManager", EffectManager)
	---@type CameraManager
	self.cameraManager = self:AddChild("CameraManager", require("LuaCat.Camera.CameraManager"))
	---@type UnitManager
	self.unitManager = self:AddChild("UnitManager", UnitManager)
	---@type SpellManager
	self.spellManager = self:AddChild("SpellManager", SpellManager)
	---@type PathManager
	self.pathManager = self:AddChild("PathManager", PathManager)
end

function CombatBase:GetTimerManager()
	return self.timerManager
end

function CombatBase:Start()
	CombatBase.super.Start(self)
	Log("=============== Combat:Start ===============")
	self.time = 0
	self.frame = 0
	self.isFinished = false
	self.fixedUpdateRemainDuration = CombatConst.Fixed_Update_Duration
	self.isStarted = true
	local gameLevelClass = ClassLoadUtil.Load(self.argDict.gameLevelClassPath) or GameLevelBase
	self.gameLevel = self:AddChild(nil, gameLevelClass)
	self.gameLevel:Start()
end

function CombatBase:Update(deltaTime, unscaledDeltaTime)
	if not self.isFixedDurationUpdate then
		self.frame = self.frame + 1
		self.time = self.time + deltaTime
		if not self:IsCanUpdate() then
			return
		end
		CombatBase.super.Update(self, deltaTime, unscaledDeltaTime)
	else
		self.fixedUpdateRemainDuration = self.fixedUpdateRemainDuration - deltaTime
		local deltaTime = CombatConst.Fixed_Update_Duration
		local unscaledDeltaTime = CombatConst.Fixed_Update_Duration
		while self.fixedUpdateRemainDuration <= 0 do
			self.frame = self.frame + 1
			self.time = self.time + deltaTime
			self.fixedUpdateRemainDuration = self.fixedUpdateRemainDuration + deltaTime
			if not self:IsCanUpdate() then
				return
			end
			CombatBase.super.Update(self, deltaTime, unscaledDeltaTime)
		end
	end
end

function CombatBase:__Update(deltaTime, unscaledDeltaTime)
	CombatBase.super.__Update(self, deltaTime, unscaledDeltaTime)
	self.timerManager:Update(deltaTime, unscaledDeltaTime)
	self.timerManager:CoUpdate(deltaTime, unscaledDeltaTime)
end

function CombatBase:_LateUpdate(deltaTime, unscaledDeltaTime)
	CombatBase.super.__LateUpdate(self, deltaTime, unscaledDeltaTime)
	self.timerManager:LateUpdate(deltaTime, unscaledDeltaTime)
	self.timerManager:CoLateUpdate(deltaTime, unscaledDeltaTime)
end

function CombatBase:_FixedUpdate(deltaTime, unscaledDeltaTime)
	CombatBase.super.__FixedUpdate(self, deltaTime, unscaledDeltaTime)
	self.timerManager:FixedUpdate(deltaTime, unscaledDeltaTime)
	self.timerManager:CoFixedUpdate(deltaTime, unscaledDeltaTime)
end

function CombatBase:SetIsFinished(is_finished)
	self.isFinished = is_finished
end

function CombatBase:IsStarted()
	return self.isStarted
end

function CombatBase:IsFinished()
	return self.isFinished
end

function CombatBase:IsCanUpdate()
	return self:IsStarted() and not self:IsFinished() and CombatBase.super.IsCanUpdate(self)
end

return CombatBase
