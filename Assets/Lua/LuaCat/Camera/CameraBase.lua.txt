---@class CameraBase:TickObject
local CameraBase = Class("CameraBase", TickObject)

---@param camera CS.UnityEngine.Camera
function CameraBase:Init(camera, isNotDestroyGameObject)
	CameraBase.super.Init(self)
	---@type CS.UnityEngine.Camera
	self.camera = camera
	self._graphicComponent:SetGameObject(self.camera.gameObject, isNotDestroyGameObject)

	---@type Vector3
	self.orgPosition = self._graphicComponent._transform.position
	---@type Vector3
	self.orgEulerAngles = self._graphicComponent._transform.eulerAngles
	---@type Quaternion
	self.orgRotation = self._graphicComponent._transform.rotation
	---@type number
	self.orgFov = self.camera.fieldOfView

	---@type Vector3
	self.currentPosition = self._graphicComponent._transform.position
	---@type Vector3
	self.currentEulerAngles = self._graphicComponent._transform.eulerAngles
	---@type Quaternion
	self.currentRotation = self._graphicComponent._transform.rotation
	---@type number
	self.currentFov = self.camera.fieldOfView
	---@type number
	self.lerpSpeed = 4

	self.shakeDataList = {}
end

function CameraBase:IsCanUpdate()
	return not self._isCanNotUpdate and CameraBase.super.IsCanUpdate(self)
end

function CameraBase:_LateUpdate(deltaTime, unscaledDeltaTime)
	CameraBase.super.__LateUpdate(self, deltaTime, unscaledDeltaTime)
	if self.currentOperation == "无" then
		self._graphicComponent._transform.position = self.currentPosition
	elseif self.currentOperation == "锁定到目标" then
		if self.lockToTransform then
			self:ApplyLockTo(deltaTime)
		end
	elseif self.currentOperation == "增量移动" then
		self:ApplyMoveByDelta(deltaTime)
	elseif self.currentOperation == "移动到目标" then
		self:ApplyMoveToTarget(deltaTime)
	end

	self.currentPosition = self._graphicComponent._transform.position
	self.currentRotation = self._graphicComponent._transform.rotation
	self.currentFov = self.camera.fieldOfView

	self:ApplyShakeScreen(deltaTime)
	self:ApplyMoveRange(deltaTime)

end

--------------------------------LockTo----------------------
function CameraBase:SetLockTo(lockToTransform)
	self.lockToTransform = lockToTransform
end

function CameraBase:ApplyLockTo(deltaTime)
	local position = self.lockToTransform.position
	self.transform.position = Vector3.Lerp(self._graphicComponent._transform.position, position, deltaTime)
end

--------------------------------MoveByDelta--------------------
function CameraBase:MoveByDelta(dx, dy, dz)
	self.currentOperation = "增量移动"
	self.moveByDeltaTargetPosition = self.currentPosition + self._graphicComponent._transform.right * dx + self._graphicComponent._transform.up * dy + self._graphicComponent._transform.forward * dz
	--if math.abs(dy) > 0.15 then
	--  self.move_by_delta_target_position = Vector3.New(self.current_position.x, self.current_position.y + dy, self.current_position.z)
	--else
	--  self.move_by_delta_target_position = self.current_position + self.transform.right * dx + self.transform.forward * dz
	--end
end

function CameraBase:ApplyMoveByDelta(deltaTime)
	self._graphicComponent._transform.position = Vector3.Lerp(self.currentPosition, self.moveByDeltaTargetPosition, self.lerpSpeed * deltaTime)
	if Vector3.SqrMagnitude(self._graphicComponent._transform.position - self.moveByDeltaTargetPosition) < 0.2 then
		self:MoveByDeltaReset()
	end
end

function CameraBase:MoveByDeltaReset()
	self._graphicComponent._transform.position = self.moveByDeltaTargetPosition
	self.currentOperation = "无"
end
-----------------------------MoveToTarget------------------------
---@param moveTo CS.UnityEngine.Transform|Vector3
---@param moveToTargetDuration number
---@param moveToTargetEulerAngles Vector3
---@param moveToTargetLookPosition Vector3
---@param isReachNeedStop boolean
function CameraBase:SettMoveToTarget(moveTo, moveToTargetDuration, moveToTargetEulerAngles, moveToTargetLookPosition, isReachNeedStop)
	if IsInstanceOf(moveTo, "Vector3") then
		---@type Vector3
		self.moveToTargetPosition = moveTo
	else
		---@type CS.UnityEngine.Transform
		self.moveToTargetTransform = moveTo
		---@type Vector3
		self.moveToTargetPosition = self.moveToTargetTransform.position
	end

	self.moveToTargetDuration = moveToTargetDuration
	if moveToTargetEulerAngles then
		---@type Quaternion
		self.moveToTargetRotation = Quaternion.Euler(moveToTargetEulerAngles.x, moveToTargetEulerAngles.y, moveToTargetEulerAngles.z)
	end
	if moveToTargetLookPosition then
		---@type Vector3
		self.moveToTargetRotation = Quaternion.LookRotation(self.moveToTargetLookPosition - self.moveToTargetPosition)
	end
	---@type boolean
	self.isReachNeedStop = isReachNeedStop

	---@type Vector3
	self.moveToTargetStartPosition = self.currentPosition
	---@type Quaternion
	self.moveToTargetStartRotation = self.currentRotation
	---@type number
	self.moveToTargetCurrentTime = 0
end

function CameraBase:ApplyMoveToTarget(deltaTime)
	if self.moveToTargetTransform then
		self.moveToTargetPosition = self.moveToTargetTransform.position
	end
	self.moveToTargetCurrentTime = self.moveToTargetCurrentTime + deltaTime
	local position
	local rotation
	if self.moveToTargetDuration == 0 or self.moveToTargetCurrentTime >= self.moveToTargetDuration then
		position = self.moveToTargetPosition
		rotation = self.moveToTargetStartRotation
		if self.isReachNeedStop then
			self:MoveToTargetReset()
		end
	else
		local percent = NumberUtil.GetPercent(self.moveToTargetCurrentTime, 0, self.moveToTargetDuration)
		position = Vector3.Lerp(self.moveToTargetStartPosition, self.moveToTargetPosition, percent)
		rotation = Quaternion.Slerp(self.moveToTargetStartRotation, self.moveToTargetStartRotation, percent)
	end
	self._graphicComponent._transform.position = position
	self._graphicComponent._transform.rotation = rotation
end

function CameraBase:MoveToTargetReset()
	self.currentOperation = "无"
	self.moveToTargetPosition = nil
	self.moveToTargetTransform = nil
	self.isReachNeedStop = false
end
-----------------------------Range---------------------------------
function CameraBase:SetMoveRange(move_range)

end

function CameraBase:ApplyMoveRange(delta_time)
end
-------------------------------------Setting------------------------
function CameraBase:ApplySetting(position, rotation, fov)
	self.currentPosition = position
	self.currentEulerAngles = rotation.eulerAngles
	self.currentRotation = rotation
	self.currentFov = fov

	self.orgPosition = position
	self.orgEulerAngles = rotation.eulerAngles
	self.orgRotation = rotation
	self.orgFov = fov
end
-------------------------------------ShakeScreen------------------------
---@param duration number
---@param posShakeRange Vector3
---@param posShakeFrequency Vector3
---@param eulerAnglesShakeRange Vector3
---@param eulerAnglesShakeFrequency Vector3
---@param fovShakeRange number
---@param fovShakeFrequency number
function CameraBase:ShakeScreen(duration, posShakeRange, posShakeFrequency, eulerAnglesShakeRange, eulerAnglesShakeFrequency, fovShakeRange, fovShakeFrequency)
	table.insert(self.shakeDataList, {
		frameTime = 0,
		duration = duration,
		posShakeRange = posShakeRange,
		posShakeFrequency = posShakeFrequency,
		eulerAnglesShakeRange = eulerAnglesShakeRange,
		eulerAnglesShakeFrequency = eulerAnglesShakeFrequency,
		fovShakeRange = fovShakeRange,
		fovShakeFrequency = fovShakeFrequency,
	})
end

function CameraBase:ApplyShakeScreen(deltaTime)
	local shakeResult = self:GetShakeResult(deltaTime)
	if shakeResult then
		local shakePosition = self.currentRotation * shakeResult.position
		self._graphicComponent._transform.position = self._graphicComponent._transform.position + shakePosition
		local shakeRotation = self.currentRotation * Quaternion.Euler(shakeResult.eulerAngles.x, shakeResult.eulerAngles.y, shakeResult.eulerAngles.z)
		self._graphicComponent._transform.rotation = shakeRotation
		self.camera.fieldOfView = self.camera.fieldOfView + shakeResult.fov
	end
end

function CameraBase:GetShakeResult(deltaTime)
	local shakePosition = Vector3.New(0, 0, 0)
	local shakeEulerAngles = Vector3.New(0, 0, 0)
	local shakeFov = 0
	for i = #self.shakeDataList, 1, -1 do
		local shakeData = self.shakeDataList[i]
		shakeData.frameTime = shakeData.frameTime + deltaTime
		if shakeData.frameTime >= shakeData.duration then
			table.remove(self.shakeDataList, i)
		else
			if shakeData.posShakeRange and shakeData.posShakeFrequency then
				shakePosition = shakePosition + self:__CalculateShakeResult_Vector3(shakeData.duration, shakeData.frameTime, shakeData.posShakeRange, shakeData.posShakeFrequency)
			end
			if shakeData.eulerAngles_shake_range and shakeData.eulerAngles_shake_frequency then
				shakeEulerAngles = shakeEulerAngles + self:__CalculateShakeResult_Vector3(shakeData.duration, shakeData.frameTime, shakeData.eulerAnglesShakeRange, shakeData.eulerAnglesShakeFrequency)
			end
			if shakeData.fovShakeRange and shakeData.fov_shake_frequency then
				shakeFov = shakeFov + self:__CalculateShakeResult_Number(shakeData.duration, shakeData.frameTime, shakeData.fovShakeRange, shakeData.fovShakeFrequency)
			end
			return {
				position = shakePosition,
				eulerAngles = shakeEulerAngles,
				fov = shakeFov
			}
		end
	end
	return nil
end

---@param duration number
---@param frameTime number
---@param shakeRange number
---@param shakeFrequency number
function CameraBase:__CalculateShakeResult_Number(duration, frameTime, shakeRange, shakeFrequency)
	local reduction = (duration - frameTime) / duration
	return math.sin(2 * math.PI * shakeFrequency * frameTime) * shakeRange * reduction
end

---@param duration number
---@param frameTime number
---@param shakeRange Vector3
---@param shakeFrequency Vector3
function CameraBase:__CalculateShakeResult_Vector3(duration, frameTime, shakeRange, shakeFrequency)
	return Vector3.New(
		self:__CalculateShakeResult_Number(duration, frameTime, shakeRange.x, shakeFrequency.x),
		self:__CalculateShakeResult_Number(duration, frameTime, shakeRange.y, shakeFrequency.y),
		self:__CalculateShakeResult_Number(duration, frameTime, shakeRange.z, shakeFrequency.z)
	)
end

return CameraBase