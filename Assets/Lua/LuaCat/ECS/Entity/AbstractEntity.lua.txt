---@class AbstractEntity:Class
---@field key string
---@field parent AbstractEntity
---@field _isDestroyed boolean
---@field isKeyUsingParentIdPool boolean
---@field isPaused boolean
---@field isNotDeleteChildRelationShipImmediately boolean @是否不立刻将child从child_key_list和children_dict中删除关联关系
---@field isNotDeleteComponentRelationShipImmediately boolean @是否不立刻将component从component_list和component_dict中删除关联关系
---@field isHasDestroyedChild boolean @是否【子孙】child中有要从child_key_list和children_dict中删除关联关系
---@field isHasDestroyedChildComponent boolean @是否【子孙】child中有要从component_list和component_dict中删除关联关系
---@field isHasDestroyedComponent boolean @是否有compoent是要从component_list和component_dict中删除关联关系
---@field isEnabled boolean
--------注意创建后记得设置key
local AbstractEntity = Class("AbstractEntity")

-----注意创建后记得设置key
function AbstractEntity:Init()
	---@type table<string, AbstractEntity>
	self.keyToChildDict = {}
	---@type table<string,AbstractEntity[]>
	self.classNameToChildListDict = {}--准确的类型
	---@type string[]
	self.childKeyList = {}
	---@type string[]
	self.childClassNameList = {}
	---@type IdPool
	self.childKeyIdPool = IdPool.New()

	---@type table<string, AbstractComponent>
	self.keyToComponentDict = {}
	---@type table<string, AbstractComponent[]>
	self.classNameToComponentListDict = {}
	---@type string[]
	self.componentKeyList = {}
	---@type string[]
	self.componentClassNameList = {}
	---@type IdPool
	self.componentKeyIdPool = IdPool.New()

	self.destroyCallback = {}
	self.resetCallback = {}

	---@type Cache
	self.cache = Cache.New()
end

function AbstractEntity:PostInit()
end

function AbstractEntity:Start(...)
end

function AbstractEntity:Refresh(...)
end

function AbstractEntity:__OnDespawn_()
	self.isHasDestroyedChild = false
	self.isHasDestroyedChildComponent = false
	self.isHasDestroyedComponent = false

	self.cache:Clear()
end

----------------------------------------------------------------------
-- child相关 ForeachChild
----------------------------------------------------------------------
function AbstractEntity:ForeachChild()
	return self.__ForeachChild, { childrenDict = self.keyToChildDict, childKeyList = self.childKeyList, count = #self.childKeyList }, 0
end

---@param i number
function AbstractEntity.__ForeachChild(childrenInfo, i)
	---@type AbstractEntity
	local child
	local childrenDict = childrenInfo.children_dict
	local child_keyList = childrenInfo.child_key_list
	local count = childrenInfo.count
	while i < count and i <= #child_keyList do
		i = i + 1
		child = childrenDict[child_keyList[i]]
		if not child:IsDestroyed() then
			return i, child
		end
	end
end

---@param childClassType Class
function AbstractEntity:ForeachChildOfType(childClassType)
	return self.__ForeachChildOfType,

	{
		childrenDict = self.keyToChildDict,
		childKeyList = self.childKeyList,
		count = #self.childKeyList,
		childClassType = childClassType
	},
	0
end

---@param i number
function AbstractEntity.__ForeachChildOfType(childrenInfo, i)
	---@type AbstractEntity
	local child
	local childrenDict = childrenInfo.children_dict
	local childKeyList = childrenInfo.child_key_list
	local count = childrenInfo.count
	local childClassType = childrenInfo.child_class_type
	while i < count and i <= #childKeyList do
		i = i + 1
		child = childrenDict[childKeyList[i]]
		if not child:IsDestroyed() and IsSubClassOf(child._className, childClassType._className) then
			return i, child
		end
	end
end

function AbstractEntity:__OnDespawn_Child()
	table.Clear(self.keyToChildDict)
	table.Clear(self.classNameToChildListDict)
	table.Clear(self.childKeyList)
	table.Clear(self.childClassNameList)
	self.parent = nil
	self.isKeyUsingParentIdPool = false
end

----------------------------------------------------------------------
-- child相关 AddChild
----------------------------------------------------------------------
---@param childKey string
---@param childClassType Class @例如: require("luacat.ecs.entity.AbstractEntity")
---@return AbstractEntity
function AbstractEntity:AddChildWithoutInit(childKey, childClassType)
	if childKey and self.keyToChildDict[childKey] then
		Error("duplicate add child:", childKey, childClassType._className)
		return
	end
	local isKeyUsingParentIdPool = not childKey
	if isKeyUsingParentIdPool then
		childKey = tostring(self.childKeyIdPool:Get())
		--再次检查键值
		if self.keyToChildDict[childKey] then
			Error("duplicate add child:", childKey, childClassType._className)
			return
		end
	end
	---@type AbstractEntity
	local child = PoolCatManagerUtil.Spawn(childClassType)
	child.key = childKey
	child.isKeyUsingParentIdPool = isKeyUsingParentIdPool
	return self:AddChild2(child)
end

---@generic T:AbstractEntity
---@param child T
---@return T
function AbstractEntity:AddChild2(child)
	if self.keyToChildDict[child.key] then
		Error("duplicate add child:", child.key, child.__class_name)
		return
	end
	child.parent = self
	self:__AddChildRelationship(child)
	return child
end

---@param childKey string
---@param childClassType Class @例如: require("luacat.ecs.entity.AbstractEntity")
---@return AbstractEntity
function AbstractEntity:AddChild(childKey, childClassType, ...)
	local child = self:AddChildWithoutInit(childKey, childClassType)
	if not child then
		--没有加成功
		return nil
	end

	child:Init(...)
	child:PostInit()
	child:SetIsEnabled(true, false)
	return child
end

---@param child AbstractEntity
function AbstractEntity:__AddChildRelationship(child)
	self.keyToChildDict[child.key] = child
	local classNameToChildList = table.GetOrAddDefault_Dict(self.classNameToChildListDict, child._className, function()
		return {}
	end)
	table.insert(classNameToChildList, child)
	table.insert(self.childKeyList, child.key)
	if not table.ContainsValue(self.childClassNameList, child._className) then
		table.insert(self.childClassNameList, child._className)
	end
end

----------------------------------------------------------------------
-- child相关 GetChild
----------------------------------------------------------------------
---@param childKey string
---@return AbstractEntity
function AbstractEntity:GetChild(childKey)
	if not self.keyToChildDict[childKey] then
		return nil
	end
	if self.keyToChildDict[childKey]:IsDestroyed() then
		return nil
	end
	return self.keyToChildDict[childKey]
end

---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:GetChildByType(childClassType)
	for _, child in self:ForeachChildOfType(childClassType) do
		return child
	end
	return nil
end

--效率问题引入的
---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:GetChildStrictlyByType(childClassType)
	if not self.classNameToChildListDict[childClassType._className] then
		return
	end
	for _, child in ipairs(self.classNameToChildListDict[childClassType._className]) do
		if not child:IsDestroyed() then
			return child
		end
	end
	return nil
end

---@param childClassType Class
---@return AbstractEntity[]
function AbstractEntity:GetChildrenByType(childClassType)
	---@type AbstractEntity[]
	local result = {}
	for _, child in self:ForeachChildOfType(childClassType) do
		table.insert(result, child)
	end
	return result
end

---@param childClassType Class
---@return AbstractEntity[]
function AbstractEntity:GetChildrenStrictlyByType(childClassType)
	---@type AbstractEntity[]
	local result = {}
	if not self.classNameToChildListDict[childClassType._className] then
		return result
	end
	for _, child in self.classNameToChildListDict[childClassType._className] do
		if not child:IsDestroyed() then
			table.insert(result, child)
		end
	end
	return result
end

----------------------------------------------------------------------
-- child相关 RemoveChild
----------------------------------------------------------------------
---@param childKey string
---@return AbstractEntity
function AbstractEntity:RemoveChild(childKey)
	if not self.keyToChildDict[childKey] then
		return nil
	end
	local child = self.keyToChildDict[childKey]
	return self:RemoveChild2(child)
end

---@param child AbstractEntity
---@return AbstractEntity
function AbstractEntity:RemoveChild2(child)
	if child:IsDestroyed() then
		return nil
	end
	child:Destroy()
	if not self.isNotDeleteChildRelationShipImmediately then
		self:__RemoveChildRelationship(child)
		self:__DespawnChildKey(child)
		PoolCatManagerUtil:Despawn(child)
	else
		self:__MarkHasDestroyedChild()
	end
	return child
end

---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:RemoveChildByType(childClassType)
	local child = self:GetChildByType(childClassType)
	if child ~= nil then
		self:RemoveChild2(child)
	end
	return child
end

---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:RemoveChildStrictlyByType(childClassType)
	local child = self:GetChildStrictlyByType(childClassType)
	if child ~= nil then
		self:RemoveChild2(child)
	end
	return child
end

---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:RemoveChildrenByType(childClassType)
	local children = self:GetChildrenByType(childClassType)
	if not table.IsNilOrEmpty(children) then
		for _, child in ipairs(children) do
			self:RemoveChild2(child)
		end
	end
	return children
end

---@param childClassType Class
---@return AbstractEntity
function AbstractEntity:RemoveChildrenStrictlyByType(childClassType)
	local children = self:GetChildrenStrictlyByType(childClassType)
	if not table.IsNilOrEmpty(children) then
		for _, child in ipairs(children) do
			self:RemoveChild2(child)
		end
	end
	return children
end

function AbstractEntity:RemoveAllChildren()
	local toRemoveChildKeyList = table.Clone(self.childKeyList)
	for _, childKey in ipairs(toRemoveChildKeyList) do
		self:RemoveChild(childKey)
	end
end

----------------------------------------------------------------------
function AbstractEntity:__MarkHasDestroyedChild()
	if not self.isHasDestroyedChild then
		self.isHasDestroyedChild = true
		if self.parent then
			self.parent:__MarkHasDestroyedChild()
		end
	end
end

---@param child AbstractEntity
function AbstractEntity:__RemoveChildRelationship(child)
	self.keyToChildDict[child.key] = nil
	table.RemoveByValue_Array(self.childKeyList, child.key)
	table.RemoveByValue_Array(self.classNameToChildListDict[child._className], child)
end

---@param child AbstractEntity
function AbstractEntity:__DespawnChildKey(child)
	if child.isKeyUsingParentIdPool then
		self.childKeyIdPool:Despawn(child.key)
		child.isKeyUsingParentIdPool = false
	end
end

function AbstractEntity:CheckDestroyed()
	--有【子孙】child中有要从child_key_list和children_dict中删除关联关系
	--或者有【子孙】child的component要从从component_list和component_dict中删除关联关系
	if self.isHasDestroyedChild or self.isHasDestroyedChildComponent then
		local child_key
		---@type AbstractEntity
		local child
		for i = #self.childKeyList, 1, -1 do
			child_key = self.childKeyList[i]
			child = self.keyToChildDict[child_key]
			child:CheckDestroyed()
			if child:IsDestroyed() then
				-- 该child自身要被delete
				self:__RemoveChildRelationship(child)
				self:__DespawnChildKey(child)
				PoolCatManagerUtil.Despawn(child)
			end
		end

		self.isHasDestroyedChild = false
		self.isHasDestroyedChildComponent = false
	end

	if self.isHasDestroyedComponent then
		self:__CheckDestroyedComponents()
		self.isHasDestroyedComponent = false
	end
end

----------------------------------------------------------------------
-- component相关 ForeachComponent 按加入的顺序遍历
----------------------------------------------------------------------
-- 按加入的顺序遍历
function AbstractEntity:ForeachComponent()
	return self.__ForeachComponent, { keyToComponentDict = self.keyToComponentDict, componentKeyList = self.componentKeyList, count = #self.componentKeyList }, 0
end

-- 按加入的顺序遍历
---@param i number
function AbstractEntity.__ForeachComponent(componentInfo, i)
	---@type AbstractComponent
	local component
	local componentKeyList = componentInfo.component_key_list
	local keyToComponentDict = componentInfo.key_to_component_dict
	local count = componentInfo.count
	while i < count do
		i = i + 1
		local componentKey = componentKeyList[i]
		component = keyToComponentDict[componentKey]
		if not component:IsDestroyed() then
			return i, component
		end
	end
end

function AbstractEntity:ForeachComponentOfType(componentClassType)
	return self.__ForeachComponentOfType, { keyToComponentDict = self.keyToComponentDict, componentKeyList = self.componentKeyList, count = #self.componentKeyList, componentClassType = componentClassType }, 0
end

---@param i number
function AbstractEntity.__ForeachComponentOfType(componentInfo, i)
	---@type AbstractComponent
	local component
	local componentKeyList = componentInfo.componentKeyList
	local keyToComponentDict = componentInfo.keyToComponentDict
	local count = componentInfo.count
	local componentClassType = componentInfo.componentClassType
	while i < count do
		i = i + 1
		local componentKey = componentKeyList[i]
		component = keyToComponentDict[componentKey]
		if not component:IsDestroyed() and IsSubClassOf(component._className, componentClassType._className) then
			return i, component
		end
	end
end

function AbstractEntity:__OnDespawn_Component()
	table.Clear(self.keyToComponentDict)
	table.Clear(self.classNameToComponentListDict)
	table.Clear(self.componentKeyList)
	table.Clear(self.componentClassNameList)
end

----------------------------------------------------------------------
-- component相关 AddComponent
----------------------------------------------------------------------
---@param componentKey string
---@param componentClassType Class
---@return AbstractComponent
function AbstractEntity:AddComponentWithoutInit(componentKey, componentClassType)
	---@type AbstractComponent
	local component = PoolCatManagerUtil.Spawn(componentClassType)
	return self:AddComponent2(component, componentKey)
end

---@param component AbstractComponent
---@param componentKey string
---@return AbstractComponent
function AbstractEntity:AddComponent2(component, componentKey)
	if componentKey then
		component.key = componentKey
	end
	if component.key and self.keyToComponentDict[component.key] then
		Error("duplicate add component:", component.key, component._className)
		return nil
	end

	local isKeyUsingParentIdPool = not componentKey
	if isKeyUsingParentIdPool then
		componentKey = tostring(self.componentKeyIdPool:Get())
		--再次检查键值
		if componentKey and self.keyToComponentDict[componentKey] then
			Error("duplicate add component:", componentKey, component._className)
			return nil
		end
	end
	component.key = componentKey
	component.isKeyUsingParentIdPool = isKeyUsingParentIdPool
	component._entity = self

	self:__AddComponentRelationship(component)
	return component
end

---@param componentKey string
---@param componentClassType Class
---@param AbstractComponent
function AbstractEntity:AddComponent(componentKey, componentClassType, ...)
	local component = self:AddComponentWithoutInit(componentKey, componentClassType)
	if not component then
		--没有加成功
		return nil
	end
	component:Init(...)
	component.PostInit()
	component:SetIsEnabled(true)
	return component
end

---@param component AbstractComponent
function AbstractEntity:__AddComponentRelationship(component)
	self.keyToComponentDict[component.key] = component
	local classNameToComponentList = table.GetOrAddDefault_Dict(self.classNameToComponentListDict, component._className, function()
		return {}
	end)
	table.insert(classNameToComponentList, component)
	table.insert(self.componentKeyList, component.key)
	if not table.ContainsValue(self.componentClassNameList, component._className) then
		table.insert(self.componentClassNameList, component._className)
	end
end

----------------------------------------------------------------------
-- component相关 GetComponent
----------------------------------------------------------------------
---@param componentKey string
---@return AbstractComponent
function AbstractEntity:GetComponent(componentKey)
	if not self.keyToComponentDict[componentKey] then
		return nil
	end
	if self.keyToComponentDict[componentKey]:IsDestroyed() then
		return nil
	end
	return self.keyToComponentDict[componentKey]
end

---@param componentClassType Class
---@return AbstractEntity
function AbstractEntity:GetComponentByType(componentClassType)
	for _, component in self:ForeachComponentOfType(componentClassType) do
		return component
	end
	return nil
end

function AbstractEntity:GetComponentStrictlyByType(componentClassType)
	if not self.classNameToComponentListDict[componentClassType._className] then
		return nil
	end
	for _, component in self.classNameToComponentListDict[componentClassType._className] do
		if not component:IsDestroyed() then
			return component
		end
	end
	return nil
end

---@param componentClassType Class
---@return AbstractEntity[]
function AbstractEntity:GetComponentsByType(componentClassType)
	---@type AbstractEntity[]
	local result = {}
	for _, component in self:ForeachComponentOfType(componentClassType) do
		table.insert(result, component)
	end
	return result
end

---@param componentClassType Class
---@return AbstractEntity[]
function AbstractEntity:GetComponentsStrictlyByType(componentClassType)
	---@type AbstractEntity[]
	local result = {}
	if not self.classNameToComponentListDict[componentClassType._className] then
		return result
	end
	for _, component in self.classNameToComponentListDict[componentClassType._className] do
		if not component:IsDestroyed() then
			table.insert(result, component)
		end
	end
	return result
end
----------------------------------------------------------------------
-- component相关 RemoveComponent
----------------------------------------------------------------------
---@param componentKey string
---@return AbstractComponent
function AbstractEntity:RemoveComponent(componentKey)
	if not self.keyToComponentDict[componentKey] then
		return nil
	end
	local component = self.keyToComponentDict[componentKey]
	return self:RemoveComponent2(component)
end

---@generic T:AbstractComponent
---@param component T
---@return T
function AbstractEntity:RemoveComponent2(component)
	if component:IsDestroyed() then
		return nil
	end
	component:Destroy()
	if not self.isNotDeleteComponentRelationShipImmediately then
		self:__RemoveComponentRelationship(component)
		self:__DespawnComponentKey(component)
		PoolCatManagerUtil.Despawn(component)
	else
		self:__MarkHasDestroyedComponent()
	end
	return component
end

---@param componentClassType AbstractComponent
function AbstractEntity:RemoveComponentByType(componentClassType)
	local component = self:GetComponentByType(componentClassType)
	if component then
		self:RemoveComponent2(component)
	end
	return component
end

---@param componentClassType AbstractComponent
function AbstractEntity:RemoveComponentStrictlyByType(componentClassType)
	local component = self:GetComponentStrictlyByType(componentClassType)
	if component then
		self:RemoveComponent2(component)
	end
	return component
end

---@param componentClassType Class @如 require("luacat.ecs.component.impl.AbstractObjectComponent")
---@return AbstractComponent
function AbstractEntity:RemoveComponentsByType(componentClassType)
	local components = self:GetComponentsByType(componentClassType)
	if not table.IsNilOrEmpty(components) then
		for _, component in ipairs(components) do
			self:RemoveComponent2(component)
		end
	end
	return components
end

---@param componentClassType Class @如 require("luacat.ecs.component.impl.AbstractObjectComponent")
---@return AbstractComponent
function AbstractEntity:RemoveComponentsStrictlyByType(componentClassType)
	local components = self:GetComponentsStrictlyByType(componentClassType)
	if not table.IsNilOrEmpty(components) then
		for _, component in ipairs(components) do
			self:RemoveComponent2(component)
		end
	end
	return components
end

function AbstractEntity:RemoveAllComponents()
	local toRemoveComponentKeyList = table.Clone(self.componentKeyList)
	for _, componentKey in ipairs(toRemoveComponentKeyList) do
		self:RemoveComponent(componentKey)
	end
end

----------------------------------------------------------------------
function AbstractEntity:__MarkHasDestroyedComponent()
	if not self.isHasDestroyedComponent then
		self.isHasDestroyedComponent = true
		if self.parent then
			self.parent:__MarkHasDestroyedChildComponent()
		end
	end
end

function AbstractEntity:__MarkHasDestroyedChildComponent()
	if not self.isHasDestroyedChildComponent then
		self.isHasDestroyedChildComponent = true
		if self.parent then
			self.parent:__MarkHasDestroyedChildComponent()
		end
	end
end

---@param component AbstractComponent
function AbstractEntity:__RemoveComponentRelationship(component)
	self.keyToComponentDict[component.key] = nil
	table.RemoveByValue_Array(self.classNameToComponentListDict[component._className], component)
	table.RemoveByValue_Array(self.componentKeyList, component.key)
end

---@param component AbstractComponent
function AbstractEntity:__DespawnComponentKey(component)
	if component.isKeyUsingParentIdPool then
		self.componentKeyIdPool:Despawn(component.key)
		component.isKeyUsingParentIdPool = false
	end
end

--主要作用是将IsDestroyed的component从component_list和component_dict中删除
function AbstractEntity:__CheckDestroyedComponents()
	---@type AbstractComponent
	local component
	local component_key
	for i = #self.componentKeyList, 1, -1 do
		component_key = self.componentKeyList[i]
		component = self.keyToComponentDict[component_key]
		if component:IsDestroyed() then
			self:__RemoveComponentRelationship(component)
			self:__DespawnComponentKey(component)
			PoolCatManagerUtil.Despawn(component)
		end
	end
end

----------------------------------------------------------------------
-- Update相关
----------------------------------------------------------------------
function AbstractEntity:IsCanUpdate()
	return self:GetIsEnabled() and not self:GetIsPaused() and not self:IsDestroyed()
end


----------------------------------------------------------------------
-- pause相关
----------------------------------------------------------------------

function AbstractEntity:SetIsPaused(isPaused, isLoopChildren)
	if self:GetIsPaused() == isPaused then
		return
	end
	self.isPaused = isPaused
	if isLoopChildren then
		self:SetAllChildrenIsPaused(isPaused)
	end
	self:SetAllComponentsIsPaused(isPaused)
	self:__SetIsPaused(isPaused)
end

function AbstractEntity:__SetIsPaused(isPaused)
end

function AbstractEntity:SetAllChildrenIsPaused(isPaused)
	for _, child in self:ForeachChild() do
		child:SetIsPaused(isPaused, true)
	end
end

function AbstractEntity:SetAllComponentsIsPaused(isPaused)
	for _, component in self:ForeachComponent() do
		component:SetIsPaused(isPaused)
	end
end

function AbstractEntity:GetIsPaused()
	return self.isPaused or false
end

function AbstractEntity:__OnDespawn_Pause()
	self.isPaused = false
end

----------------------------------------------------------------------
-- Enable相关
----------------------------------------------------------------------
---@param isEnabled boolean
function AbstractEntity:SetIsEnabled(isEnabled, isLoopChildren)
	if self:GetIsEnabled() == isEnabled then
		return
	end
	if isLoopChildren then
		for _, child in self:ForeachChild() do
			child:SetIsEnabled(isEnabled, true)
		end
	end
	for _, component in self:ForeachComponent() do
		component:SetIsEnabled(isEnabled)
	end

	self.isEnabled = isEnabled
	self:_SetIsEnabled(isEnabled)
	if isEnabled then
		self:OnEnable()
	else
		self:OnDisable()
	end
end

function AbstractEntity:_SetIsEnabled(isEnabled)
end

function AbstractEntity:GetIsEnabled()
	return self.isEnabled or false
end

function AbstractEntity:OnEnable()
end

function AbstractEntity:OnDisable()
end

function AbstractEntity:__OnDespawn_Enable()
	self.isEnabled = false
end

----------------------------------------------------------------------
-- Reset相关
----------------------------------------------------------------------
---@param isLoopChildren boolean
function AbstractEntity:Reset(isLoopChildren)
	if isLoopChildren then
		self:ResetAllChildren()
	end
	self:ResetAllComponents()
	self:_Reset()
	self:__PostReset()
end

function AbstractEntity:_Reset()
end

function AbstractEntity:__PostReset()
	DelegateUtil.InvokeCallback(self.resetCallback)
	self.resetCallback = {}
end

function AbstractEntity:ResetAllChildren()
	for _, child in self:ForeachChild() do
		child:Reset(true)
	end
end

function AbstractEntity:ResetAllComponents()
	for _, component in self:ForeachComponent() do
		component:Reset()
	end
end

function AbstractEntity:__OnDespawn_Reset()
	self.resetCallback = nil
end

----------------------------------------------------------------------
-- Destroy相关
----------------------------------------------------------------------
function AbstractEntity:IsDestroyed()
	return self._isDestroyed or false
end

function AbstractEntity:Destroy()
	if self:IsDestroyed() then
		return
	end
	self:RemoveAllChildren()
	self:SetIsEnabled(false, false)
	self:SetIsPaused(false, false)
	self:RemoveAllComponents()
	self:_Destroy()
	self._isDestroyed = true
	self:__PostDestroy()
	self.cache:Clear()
end

function AbstractEntity:_Destroy()

end

function AbstractEntity:__PostDestroy()
	DelegateUtil.InvokeCallback(self.destroyCallback)
	self.destroyCallback = {}
end

function AbstractEntity:__OnDespawn_Destroy()
	self._isDestroyed = false
	self.key = nil
end

function AbstractEntity:OnDespawn()
	self:__OnDespawn_()
	self:__OnDespawn_Child()
	self:__OnDespawn_Component()
	self:__OnDespawn_Destroy()
	self:__OnDespawn_Enable()
	self:__OnDespawn_Pause()
	self:__OnDespawn_Reset()
end

return AbstractEntity