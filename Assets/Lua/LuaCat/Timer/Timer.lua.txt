-- 1、定时器需要暂停使用pause、恢复使用unpause
-- 2、定时器使用stop停止，一旦停止逻辑层脚本就应该将引用置空，因为它随后会被管理类回收，引用已经不再正确

---@class Timer:Class
---@field delay number
---@field target
---@field interval  @等于0的时候，每帧都会调用
---@field isUseUnscaledDeltaTime boolean
---@field remainDuration number
---@field state @idle,running,paused,finished
---@field is_finished boolean
local Timer = Class("Timer")

Timer.State = {
	Idle = "Idle",
	Running = "Running",
	Paused = "Paused",
	Finished = "Finished"
}

Timer.UpdateMode = {
	Update = "Update",
	FixedUpdate = "FixedUpdate",
	LateUpdate = "LateUpdate",
}

-- target_func  返回false表示不继续执行，结束
---@param targetFuncArgs table
function Timer:Init(targetFunc, targetFuncArgs, delay, interval, updateMode, isUseUnscaledDeltaTime, isCoroutineTimer, isUseFrame)
	-- 时长，秒或者帧
	self.delay = delay or 0
	-- 回调函数
	self.targetFunc = targetFunc
	-- targetFunc的参数
	self.targetFuncArgs = targetFuncArgs
	-- 间隔
	self.interval = interval or 0
	-- 使用deltaTime计时，还是采用unscaledDeltaTime计时
	self.isUseUnscaledDeltaTime = isUseUnscaledDeltaTime
	-- update_mode: update,lateUpdate,fixedUpdate
	self.updateMode = updateMode or Timer.UpdateMode.Update
	-- 是否是coroutine模式
	self.isCoroutineTimer = isCoroutineTimer
	-- 是否使用frame模式
	self.isUseFrame = isUseFrame
	--  下次触发剩余时间
	self.remainDuration = delay
	-- 当前状态
	self.state = Timer.State.Idle
end

-- 启动计时
function Timer:Start()
	self.state = Timer.State.Running
end

-- 暂停/恢复计时
function Timer:SetIsPaused(isPaused)
	if isPaused and self.state == Timer.State.Paused then
		return
	end
	if not isPaused and not self.state == Timer.State.Paused then
		return
	end
	if isPaused then
		self.preState = self.state
	end
	self.state = isPaused and Timer.State.Paused or self.preState
end

function Timer:DoUpdate(deltaTime, unscaledDeltaTime)
	if self.state ~= Timer.State.Running then
		return
	end
	local targetDeltaTime = self.isUseUnscaledDeltaTime and unscaledDeltaTime or deltaTime
	if self.isUseFrame then
		self.remainDuration = self.remainDuration - 1
	else
		self.remainDuration = self.remainDuration - targetDeltaTime
	end
	--if self.a =="a" then
	--  log(self.remain_duration)
	--end
	if self.remainDuration > 0 then
		return
	end
	while self.remainDuration <= 0 do
		--运行状态
		local status, ret
		if self.targetFuncArgs then
			table.SafePackArray(self.targetFuncArgs)
			status, ret = pcall(self.targetFunc, table.SafeUnpack(self.targetFuncArgs))
		else
			status, ret = pcall(self.targetFunc)
		end
		if not status then
			-- 调用出错
			local err = ret
			self:Finish()
			Error(err)
			return
		else
			local isNotFinished = ret
			if not isNotFinished then
				self:Finish()
				return
			end
		end
		if self.interval > 0 then
			self.remainDuration = self.remainDuration + self.interval
			if self.remainDuration == 0 then
				-- == 0的情况下跳出循环不处理
				break
			end
		else
			break
		end
	end
end



-- 停止计时
function Timer:Stop()
	self:Finish()
end

function Timer:Finish()
	self.state = Timer.State.Finished
end



-- 是否已经完成计时
function Timer:IsFinished()
	return self.state == Timer.State.Finished
end

function Timer:OnDespawn()
	self.delay = 0
	self.targetFunc = nil
	self.targetFuncArgs = nil
	self.interval = 0
	self.isUseUnscaledDeltaTime = nil
	self.updateMode = Timer.UpdateMode.Update
	self.isCoroutineTimer = nil
	self.isUseFrame = nil
	self.remainDuration = nil
	self.state = Timer.State.Idle
end

return Timer